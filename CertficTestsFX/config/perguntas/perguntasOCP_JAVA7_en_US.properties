#Generated by ResourceBundle Editor (http://essiembre.github.io/eclipse-rbe/)

teste30.exercicio1.ajuda.cabecalho  = Use access modifiers: private, protected, and public / Overload constructors and methods / Use package and import statements
teste30.exercicio1.ajuda.conteudo   = First Tip: A package enables you to create a namespace to group related classes and interfaces together.\r\n\r\nSecond Tip: A base class overloads its base class method, as required. Making derived classes overload their base class methods doesn\u2019t make it an incorrect or inefficient design.
teste30.exercicio1.enunExtra        = \ 
teste30.exercicio1.numOpcao         = Select 3 option
teste30.exercicio1.opcao_0          = A - Create related classes in a single package.
teste30.exercicio1.opcao_1          = B - Don\u2019t make derived classes overload methods from their base class.
teste30.exercicio1.opcao_2          = C - Expose the functionality of your classes using public methods.
teste30.exercicio1.opcao_3          = D - Create private methods to work as helper methods for the public methods.
teste30.exercicio1.opcao_4          = E - None of the above.
teste30.exercicio1.questao          = Which of the following points should you incorporate in your application design?
teste30.exercicio1.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.85.
teste30.exercicio10.ajuda.cabecalho = Create a generic class
teste30.exercicio10.ajuda.conteudo  = Tip: A raw type doesn\u2019t include the generic information. For the generic type List<T>, its raw type is List. You don\u2019t need to define a raw type explicitly for any generic class or interface. You can access the raw type of all the generic types.
teste30.exercicio10.enunExtra       = \ 
teste30.exercicio10.numOpcao        = Select 2 option
teste30.exercicio10.opcao_0         = A - If you define a generic class, you must define its corresponding raw class explicitly.
teste30.exercicio10.opcao_1         = B - On compilation, type information is erased from a generic class.
teste30.exercicio10.opcao_2         = C - A generic method can be defined within a generic class or a regular class.
teste30.exercicio10.opcao_3         = D - Generic interfaces might not accept multiple generic type parameters.
teste30.exercicio10.opcao_4         = E - None of the above
teste30.exercicio10.questao         = Which of the following statements are true about generic classes, interfaces, and methods?
teste30.exercicio10.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.338.
teste30.exercicio11.ajuda.cabecalho = Format strings using the formatting parameters: %b, %c, %d, %f, and %s in format strings
teste30.exercicio11.ajuda.conteudo  = By default, %f prints out six digits after the decimal number. It also rounds off the last digit. So num1=%f outputs 7.123457 and not 7.123456.\r\nBecause the double literal 8.12345678 is explicitly casted to an int value, num2 contains the integer part of the double literal 8.12345678, that is, 8. %2d sets the total width of the output to 2 digits, padded with spaces and right-aligned by default. It outputs a space preceding the digit 8.\r\nFor all non-Boolean primitive values, %b outputs true.
teste30.exercicio11.enunExtra       = \r\n\r\nclass Format1 {\r\n\u0009public static void main(String... args) {\r\n\u0009\u0009double num1 = 7.12345678;\r\n\u0009\u0009int num2 = (int) 8.12345678;\r\n\u0009\u0009System.out.printf("num1=%f, num2=%2d, %b", num1, num2, num2);\r\n\u0009}\r\n}
teste30.exercicio11.numOpcao        = Select 1 option
teste30.exercicio11.opcao_0         = A - num1=7.123456, num2= 8, true
teste30.exercicio11.opcao_1         = B - num1=7.123456, num2=8, true
teste30.exercicio11.opcao_2         = C - num1=7.123457, num2= 8, true
teste30.exercicio11.opcao_3         = D - Compilation error
teste30.exercicio11.opcao_4         = E - num1=7.1234, num2=8, false
teste30.exercicio11.questao         = What is the output of the following code ?
teste30.exercicio11.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.387.
teste30.exercicio12.ajuda.cabecalho = Search, parse, and replace strings by using regular expressions, using expression patterns for matching limited to: . (dot), * (star), + (plus), ?, \\d, \\D, \\s, \\S, \\w, \\W, \\b, \\B, [], ()
teste30.exercicio12.ajuda.conteudo  = The last argument (5dogs-total846) is ignored when you use the following command line because a space precedes it.\r\n\r\njava -ea Regex1 \\d\\d 761cars8 5dogs-total846\r\n\r\nWhen you pass the regex by using the command-line arguments, you don\u2019t need to escape the backslashes. It\u2019s required only for literal string values.\r\n\\d\\d will match two adjacent digits in the literal 761cars8\u2014that is, 76. It won\u2019t match 61 because the digit 6 was already consumed in finding 76. By default, Java\u2019s regex engine won\u2019t use characters that have already been consumed.
teste30.exercicio12.enunExtra       = \r\n\r\nclass Regex1 {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Pattern pattern = Pattern.compile(args[0]);\r\n\u0009\u0009Matcher matcher = pattern.matcher(args[1]);\r\n\u0009\u0009boolean found = false;\r\n\u0009\u0009while (found = matcher.find()) {\r\n\u0009\u0009\u0009System.out.println(matcher.group());\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste30.exercicio12.numOpcao        = Select 1 option
teste30.exercicio12.opcao_0         = A - 76  /  61
teste30.exercicio12.opcao_1         = B - 76  /  61  /  84  /  46
teste30.exercicio12.opcao_2         = C - 76  /  84
teste30.exercicio12.opcao_3         = D - No output
teste30.exercicio12.opcao_4         = E - None of the above
teste30.exercicio12.questao         = Given the following command line\r\n\r\njava Regex1 \\d\\d 761cars8 5dogs-total846\r\n\r\nwhat is the output of the following code?
teste30.exercicio12.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.387.
teste30.exercicio13.ajuda.cabecalho = Format strings using the formatting parameters: %b, %c, %d, %f, and %s in format strings
teste30.exercicio13.ajuda.conteudo  = You\u2019ll get runtime exceptions if you use either of the following for a format specifier:\r\n\r\n   - An invalid data type\r\n   - An invalid combination of flags
teste30.exercicio13.enunExtra       = \r\n\r\nString eJava = "Guru";\r\nInteger start = 100;\r\nboolean win = true;\r\nFloat duration = new Float(-1099.9999);
teste30.exercicio13.numOpcao        = Select 2 option
teste30.exercicio13.opcao_0         = A - System.out.format("%d", eJava);
teste30.exercicio13.opcao_1         = B - System.out.printf("%s", start);
teste30.exercicio13.opcao_2         = C - System.out.printf("[%-12b]", win);
teste30.exercicio13.opcao_3         = D - System.out.format("%s12", eJava);
teste30.exercicio13.opcao_4         = E - System.out.format("%d", duration);
teste30.exercicio13.questao         = Given the following variables, which options will throw exceptions at runtime?
teste30.exercicio13.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.388.
teste30.exercicio14.ajuda.cabecalho = Test invariants by using assertions
teste30.exercicio14.ajuda.conteudo  = Tip: For the longer form of the assert statement that uses two expressions, you can\u2019t enclose both expressions within a single parentheses.
teste30.exercicio14.enunExtra       = \ 
teste30.exercicio14.numOpcao        = Select 4 option
teste30.exercicio14.opcao_0         = A - assert(s == null : s = new String());
teste30.exercicio14.opcao_1         = B - assert s == null : s = new String();
teste30.exercicio14.opcao_2         = C - assert(s == null) : s = new String();
teste30.exercicio14.opcao_3         = D - assert(s.equals("assert"));
teste30.exercicio14.opcao_4         = E - assert s.equals("assert");
teste30.exercicio14.questao         = Given the following line of code\r\n\r\nString s = "assert";\r\n\r\nwhich of the following code options will compile successfully? (Choose all that apply.)
teste30.exercicio14.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.448.
teste30.exercicio15.ajuda.cabecalho = Auto-close resources with a try-with-resources statement
teste30.exercicio15.ajuda.conteudo  = The constructor of class Box throws a RuntimeException, and so the box variable isn\u2019t initialized in the try-with-resources statement. Method close() of class Box isn\u2019t called implicitly because execution didn\u2019t proceed inside the try block. \r\nWhen try-with-resources throws an exception, the control is transferred to the catch block. In this case, the exception handler prints catch:java.lang.Runtime- Exception. The finally block always executes, thereafter printing finally.
teste30.exercicio15.enunExtra       = \r\n\r\nclass Box implements AutoCloseable {\r\n\u0009Box() {\r\n\u0009\u0009throw new RuntimeException();\r\n\u0009}\r\n\r\n\u0009public void close() throws Exception {\r\n\u0009\u0009System.out.println("close");\r\n\u0009\u0009throw new Exception();\r\n\u0009}\r\n}\r\n\r\nclass EJavaFactory {\r\n\u0009public static void main(String args[]) {\r\n\u0009\u0009try (Box box = new Box()) {\r\n\u0009\u0009\u0009box.close();\r\n\u0009\u0009} catch (Exception e) {\r\n\u0009\u0009\u0009System.out.println("catch:" + e);\r\n\u0009\u0009} finally {\r\n\u0009\u0009\u0009System.out.println("finally");\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste30.exercicio15.numOpcao        = Select 1 option
teste30.exercicio15.opcao_0         = A - catch:java.lang.RuntimeException  /  close  /  finally
teste30.exercicio15.opcao_1         = B - catch:java.lang.RuntimeException  /  finally
teste30.exercicio15.opcao_2         = C - catch:java.lang.RuntimeException  /  close
teste30.exercicio15.opcao_3         = D - close  /  finally
teste30.exercicio15.opcao_4         = E - Compilation exception
teste30.exercicio15.questao         = What\u2019s the output of the following code?
teste30.exercicio15.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.448.
teste30.exercicio16.ajuda.cabecalho = Use streams to read from and write to files by using classes in the java.io package including BufferedReader, BufferedWriter, File, FileReader, FileWriter, DataInput-Stream, DataOutputStream, ObjectOutputStream, ObjectInputStream, and PrintWriter
teste30.exercicio16.ajuda.conteudo  = dos.writeDouble(999.999) writes 8 bytes of data to the underlying stream, and dis.read() reads a single byte of data from the underlying stream, interprets it as an integer value, and outputs it. So the code neither prints 999.999 nor throws an EOFException.
teste30.exercicio16.enunExtra       = \ 
teste30.exercicio16.numOpcao        = Select 1 option
teste30.exercicio16.opcao_0         = A - 999.999  /  -1
teste30.exercicio16.opcao_1         = B - 999  /  999
teste30.exercicio16.opcao_2         = C - 999.999  /  EOFException
teste30.exercicio16.opcao_3         = D - Compilation error
teste30.exercicio16.opcao_4         = E - None of the above
teste30.exercicio16.questao         = What\u2019s the output of the following code?\r\n\r\n\r\nimport java.io.*;\r\n\r\nclass Q1 {\r\n\u0009public static void main(String args[]) throws IOException {\r\n\u0009\u0009DataOutputStream dos = new DataOutputStream(new FileOutputStream("contacts.txt"));\r\n\u0009\u0009dos.writeDouble(999.999);\r\n\u0009\u0009DataInputStream dis = new DataInputStream(new FileInputStream("contacts.txt"));\r\n\u0009\u0009System.out.println(dis.read());\r\n\u0009\u0009System.out.println(dis.read());\r\n\u0009\u0009dis.close();\r\n\u0009\u0009dos.close();\r\n\u0009}\r\n\r\n}
teste30.exercicio16.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.504.
teste30.exercicio17.ajuda.cabecalho = Read and write data from the console
teste30.exercicio17.ajuda.conteudo  = Tip: A console isn\u2019t available to a JVM if it\u2019s started using another program or a background process, or if the underlying OS doesn\u2019t support it. In such cases, console.readLine throws a NullPointerException.
teste30.exercicio17.enunExtra       = \r\n\r\nimport java.io.*;\r\n\r\nclass ReadFromConsole {\r\n\u0009public static void main(String args[]) throws IOException {\r\n\u0009\u0009Console console = System.console();\r\n\u0009\u0009String name = "";\r\n\u0009\u0009while (name.trim().equals("")) {\r\n\u0009\u0009\u0009name = console.readLine("What is your name?\\n");\r\n\u0009\u0009\u0009console.printf(name);\r\n\u0009\u0009}\r\n    }\r\n}
teste30.exercicio17.numOpcao        = Select 3 option
teste30.exercicio17.opcao_0         = A - Class ReadFromConsole can be used to repeatedly prompt a user to enter a name, until the user doesn\u2019t enter a value.
teste30.exercicio17.opcao_1         = B - console.readLine prints the prompt What is your name? and waits for the user to enter a value.
teste30.exercicio17.opcao_2         = C - console.printf(name) prints the value, entered by the user, back to the console.
teste30.exercicio17.opcao_3         = D - Class ReadFromConsole can never throw a NullPointerException.
teste30.exercicio17.opcao_4         = E - None of the above
teste30.exercicio17.questao         = Which options are true for the following code?
teste30.exercicio17.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.504.
teste30.exercicio18.ajuda.cabecalho = Use streams to read from and write to files by using classes in the java.io package including BufferedReader, BufferedWriter, File, FileReader, FileWriter, DataInput-Stream, DataOutputStream, ObjectOutputStream, ObjectInputStream, and PrintWriter
teste30.exercicio18.ajuda.conteudo  = First Tip: A PrintWriter can be used to write to a file, an OutputStream, and a Writer.\r\n\r\nSecond Tip: Some of the constructors of PrintWriter may throw I/O exceptions (for example, when a file couldn\u2019t be found). But none of the methods of PrintWriter throw an exception. You can use checkError() to verify if an error has occurred (for example, format conversion has failed).
teste30.exercicio18.enunExtra       = \ 
teste30.exercicio18.numOpcao        = Select 1 option
teste30.exercicio18.opcao_0         = A - PrintWriter can be used to write a String to the text file data.txt.
teste30.exercicio18.opcao_1         = B - PrintWriter can be used to write to FileOutputStream.
teste30.exercicio18.opcao_2         = C - PrintWriter\u2019s format and println methods can write a formatted string by using the specified format string and arguments.
teste30.exercicio18.opcao_3         = D - None of the methods or constructors of class PrintWriter throw I/O exceptions.
teste30.exercicio18.opcao_4         = E - None of the above
teste30.exercicio18.questao         = Select the incorrect statements.
teste30.exercicio18.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.505.
teste30.exercicio19.ajuda.cabecalho = Operate on file and directory paths with the Path class
teste30.exercicio19.ajuda.conteudo  = Tip: The call path.resolveSibling("Q8_1.class") will resolve the path from file Q8_1.class against the parent directory of file Hello.txt.\r\nBecause these files exist in the same directory, a (valid) path to file Q8_1.class is returned. So Files.delete() will not delete file Hello.txt, but Q8_1.class instead.
teste30.exercicio19.enunExtra       = \r\n\r\nwhich options when inserted at /* INSERT CODE HERE */will delete the file represented by the Path object path?\r\n\r\nimport java.nio.file.*;\r\n\r\nclass Q8_1 {\r\n\u0009public static void main(String... args) throws Exception {\r\n\u0009\u0009Path path = Paths.get("Hello.txt");\r\n\u0009\u0009Files.delete(/* INSERT CODE HERE */);\r\n\u0009}\r\n}
teste30.exercicio19.numOpcao        = Select 2 option
teste30.exercicio19.opcao_0         = A - path.toAbsolutePath()
teste30.exercicio19.opcao_1         = B - path.resolveSibling("Q8_1.class")
teste30.exercicio19.opcao_2         = C - path.toRealPath()
teste30.exercicio19.opcao_3         = D - path.resolve()
teste30.exercicio19.opcao_4         = E - None of the above
teste30.exercicio19.questao         = Given the following directory structure\r\n\r\nroot dir\r\n|- MyDir\r\n   |- 8_1.java\r\n   |- 8_1.class\r\n   |- Hello.txt
teste30.exercicio19.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.568.
teste30.exercicio2.ajuda.cabecalho  = Overload constructors and methods
teste30.exercicio2.ajuda.conteudo   = When a class is compiled, the contents of its initializer block are added to its constructor, just before its own contents. For example, here\u2019s the decompiled code for class Wood. As you can see, the contents of its initializer block are added to its constructor:\r\n\r\nclass Wood {\r\n  public Wood() {\r\n    System.out.println("Wood:init");\r\n    System.out.println("Wood");\r\n  }\r\n}
teste30.exercicio2.enunExtra        = \r\n\r\nclass Wood {\r\n\u0009public Wood() {\r\n\u0009\u0009System.out.println("Wood");\r\n\u0009}\r\n\r\n\u0009{\r\n\u0009\u0009System.out.println("Wood:init");\r\n\u0009}\r\n}\r\n\r\nclass Teak extends Wood {\r\n\u0009{\r\n\u0009\u0009System.out.println("Teak:init");\r\n\u0009}\r\n\r\n\u0009public Teak() {\r\n\u0009\u0009System.out.println("Teak");\r\n\u0009}\r\n\r\n\u0009public static void main(String args[]) {\r\n\u0009\u0009new Teak();\r\n\u0009}\r\n}
teste30.exercicio2.numOpcao         = Select 1 option
teste30.exercicio2.opcao_0          = A - Wood:init  /  Wood  /  Teak:init  /  Teak
teste30.exercicio2.opcao_1          = B - Wood  /  Wood:init  /  Teak:init  /  Teak
teste30.exercicio2.opcao_2          = C - Wood:init  /  Teak:init  /  Wood  /  Teak
teste30.exercicio2.opcao_3          = D - Wood  /  Wood:init  /  Teak  /  Teak:init
teste30.exercicio2.opcao_4          = E - Wood:init  /  Teak  /  Teak:init  /  Wood
teste30.exercicio2.questao          = What is the output of the following code?
teste30.exercicio2.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.86.
teste30.exercicio20.ajuda.cabecalho = Operate on file and directory paths with the Path class
teste30.exercicio20.ajuda.conteudo  = The getRoot method returns the root of a path for an absolute path and null for a relative path. Because "/main/sub/notes/file.txt" starts with a /, it\u2019s considered an absolute path and getRoot will return / or \\ depending on your underlying OS (\\ for Windows and / for UNIX).\r\n\r\nMethod getName() excludes the root of a path and returns the element of this path, specified by the index parameter to this method. The element closest to the root in the directory hierarchy has an index of 0 and the element farthest from the root has an index of count-1 (where count is the total number of Path elements). Method subpath() (small p) returns the subsequence of the name elements of a Path, starting at the method parameter startIndex (inclusive) up to the name element at endIndex (exclusive).
teste30.exercicio20.enunExtra       = \ 
teste30.exercicio20.numOpcao        = Select 1 option
teste30.exercicio20.opcao_0         = A - \\main:null  /  file.txt:Hello.java  /  sub\\notes\\file.txt:code\\Hello.java
teste30.exercicio20.opcao_1         = B - \\:null  /  file.txt:Hello.java  /  sub\\notes:code
teste30.exercicio20.opcao_2         = C - main:code  /  file.txt:Hello.java  /  sub\\notes:code
teste30.exercicio20.opcao_3         = D - \\:null  /  main:code  /  sub\\notes:code
teste30.exercicio20.opcao_4         = E - Compilation fails
teste30.exercicio20.questao         = What is the output of the following code?\r\n\r\n\r\nclass Q8_2 {\r\n\u0009public static void main(String... args) {\r\n\u0009\u0009Path path1 = FileSystems.getDefault().getPath("/main/sub/notes/\r\n\u0009\u0009file.txt");\r\n\u0009\u0009Path path2 = Paths.get("code/Hello.java");\r\n\u0009\u0009System.out.println(path1.getRoot()+ ":" + path2.getRoot());\r\n\u0009\u0009System.out.println(path1.getName(0) + ":" + path2.getName(0));\r\n\u0009\u0009System.out.println(path1.subpath(1, 3) + ":" + path2.subpath(0,1));\r\n\u0009}\r\n}
teste30.exercicio20.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.569.
teste30.exercicio21.ajuda.cabecalho = Create and use PreparedStatement and CallableStatement objects
teste30.exercicio21.ajuda.conteudo  = You can\u2019t use method executeUpdate() to execute a SQL SELECT query. If you do, you\u2019ll get a SQLException with a similar message:\r\n\r\njava.sql.SQLException: Can not issue executeUpdate() for SELECTs\r\n\r\nSimilarly, you can\u2019t execute data deletion and modification queries with method executeQuery(). If you do so, you\u2019ll get a SQLException:\r\n\r\njava.sql.SQLException: Can not issue data manipulation statements with executeQuery().
teste30.exercicio21.enunExtra       = \r\n\r\nclass PrepStatement {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009try {\r\n\u0009\u0009\u0009String query = "....."; // line1\r\n\u0009\u0009\u0009Connection con = getConnection();\r\n\u0009\u0009\u0009PreparedStatement statement = con.prepareStatement(query);\r\n\u0009\u0009\u0009System.out.println(statement.executeUpdate());\r\n\u0009\u0009} catch (SQLException e) {\r\n\u0009\u0009\u0009System.out.println(e);\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste30.exercicio21.numOpcao        = Select 3 option
teste30.exercicio21.opcao_0         = A - Line 1 defines a SQL SELECT statement that returned zero rows.
teste30.exercicio21.opcao_1         = B - Line 1 defines a SQL UPDATE statement that affected zero rows.
teste30.exercicio21.opcao_2         = C - Line 1 defines a SQL DELETE statement that affected zero rows.
teste30.exercicio21.opcao_3         = D - Line 1 defines a SQL CREATE TABLE statement, which would always return zero rows.
teste30.exercicio21.opcao_4         = E - Compilation fails
teste30.exercicio21.questao         = Given that method getConnection() returns a valid Connection object, the query variable defines a valid SQL statement, and class PrepStatement prints 0, select the options for the following code that can be correct individually:
teste30.exercicio21.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.619.
teste30.exercicio22.ajuda.cabecalho = Describe the interfaces that make up the core of the JDBC API (including the Driver, Connection, Statement, and ResultSet interfaces and their relationship to provider implementations)
teste30.exercicio22.ajuda.conteudo  = One of the goals of JDBC 4.1, which is shipped with Java 7, is to be consistent with SQL:2003. JDBC 3.0 supported SQL99 features that were widely supported by the industry. JDBC 4.1 is supporting major components of SQL:2003.
teste30.exercicio22.enunExtra       = \ 
teste30.exercicio22.numOpcao        = Select 1 option
teste30.exercicio22.opcao_0         = A - SQL99
teste30.exercicio22.opcao_1         = B - SQL:2003
teste30.exercicio22.opcao_2         = C - SQL:2010
teste30.exercicio22.opcao_3         = D - SQL7
teste30.exercicio22.opcao_4         = E - None of the above
teste30.exercicio22.questao         = Which SQL standard is JDBC 4.1 (Java 7) consistent with?
teste30.exercicio22.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.619.
teste30.exercicio23.ajuda.cabecalho = Create and use the Thread class and the Runnable interface
teste30.exercicio23.ajuda.conteudo  = Each thread instance oak and maple, when started, will output the values of enum Seasons\u2014that is, SPRING and SUMMER (always in this order). The order of the elements returned by Seasons.values() isn\u2019t random. The enum values are always returned in the order in which they are defined.\r\n\r\nYou can\u2019t guarantee whether thread oak completes or begins its execution before or after thread maple. The thread scheduler can start oak, make it print Oak-SPRING, run maple so that it prints Maple-SPRING, return the control to oak, or run maple to completion. Whatever the sequence, the happens-before contract guarantees that code in a thread executes in the order it\u2019s defined. So the thread oak or maple can never print the enum value SUMMER before the enum value SPRING.
teste30.exercicio23.enunExtra       = \ 
teste30.exercicio23.numOpcao        = Select 4 option
teste30.exercicio23.opcao_0         = A - Oak-SPRING Maple-SPRING Oak-SUMMER Maple-SUMMER
teste30.exercicio23.opcao_1         = B - Maple-SPRING Oak-SPRING Oak-SUMMER Maple-SUMMER
teste30.exercicio23.opcao_2         = C - Oak-SUMMER Maple-SUMMER Oak-SPRING Maple-SPRING
teste30.exercicio23.opcao_3         = D - Oak-SPRING Oak-SUMMER Maple-SPRING Maple-SUMMER
teste30.exercicio23.opcao_4         = E - Maple-SPRING Maple-SUMMER Oak-SPRING Oak-SUMMER
teste30.exercicio23.questao         = What is the probable output of the following code?\r\n\r\n\r\nenum Seasons {\r\n\u0009SPRING, SUMMER\r\n}\r\n\r\nclass ETree extends Thread {\r\n\u0009String name;\r\n\r\n\u0009public ETree(String name) {\r\n\u0009\u0009this.name = name;\r\n\u0009}\r\n\r\n\u0009public void run() {\r\n\u0009\u0009for (Seasons season : Seasons.values())\r\n\u0009\u0009\u0009System.out.print(name + "-" + season + " ");\r\n\u0009}\r\n\r\n\u0009public static void main(String args[]) {\r\n\u0009\u0009ETree oak = new ETree("Oak");\r\n\u0009\u0009oak.start();\r\n\u0009\u0009ETree maple = new ETree("Maple");\r\n\u0009\u0009maple.start();\r\n\u0009}\r\n}
teste30.exercicio23.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.671.
teste30.exercicio24.ajuda.cabecalho = Create and use the Thread class and the Runnable interface
teste30.exercicio24.ajuda.conteudo  = The following code creates an anonymous class that subclasses class Thread. Its instance is referred by bug, a reference variable of type Thread.\r\n\r\nThread bug = new Thread() {\r\n    public void run() {\r\n        System.out.print("check bugs");\r\n    }\r\n};\r\n\r\nThe variable reportQA refers to an anonymous class instance that overrides its method run(). So calling reportQA.run() executes the overridden method run() and prints check bugs only once.
teste30.exercicio24.enunExtra       = \ 
teste30.exercicio24.numOpcao        = Select 2 option
teste30.exercicio24.opcao_0         = A - Replacing reportQA.run() with reportQA.start() will generate the same output on the system\u2019s console.
teste30.exercicio24.opcao_1         = B - Code prints check bugs once. 
teste30.exercicio24.opcao_2         = C - Code prints check bugs in an infinite loop.
teste30.exercicio24.opcao_3         = D - Replacing reportQA.run() with reportQA.start() will throw a compilation exception.
teste30.exercicio24.opcao_4         = E - Code prints check bugs twice.
teste30.exercicio24.questao         = Examine the following code and select the correct options.
teste30.exercicio24.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.671.
teste30.exercicio25.ajuda.cabecalho = Create and use the Thread class and the Runnable interface
teste30.exercicio25.ajuda.conteudo  = Class EPen implements the Runnable interface; it doesn\u2019t extend class Thread. So it doesn\u2019t have access to method start(). Calling start() at line 4 results in the compilation failure.
teste30.exercicio25.enunExtra       = \ 
teste30.exercicio25.numOpcao        = Select 1 option
teste30.exercicio25.opcao_0         = A - It prints eJava once.
teste30.exercicio25.opcao_1         = B - It prints eJava multiple times.
teste30.exercicio25.opcao_2         = C - Compilation error
teste30.exercicio25.opcao_3         = D - Runtime exception
teste30.exercicio25.opcao_4         = E - None of the above
teste30.exercicio25.questao         = What is the output of the following code?\r\n\r\n\r\n1. class EPen implements Runnable {\r\n2.     public void run() {\r\n3.         System.out.println("eJava");\r\n4.         start();\r\n5.     }\r\n6.     public static void main(String... args) {\r\n7.         new Thread(new EPen()).start();\r\n8.     }\r\n9. }
teste30.exercicio25.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.671.
teste30.exercicio26.ajuda.cabecalho = Use collections from the java.util.concurrent package with a focus on the advantages over and differences from the traditional java.util collections
teste30.exercicio26.ajuda.conteudo  = Tip: ConcurrentList, ConcurrentArrayList and CopyOnReadWriteArrayListJava API doesn\u2019t define\r\nthese interfaces or classes.
teste30.exercicio26.enunExtra       = \ 
teste30.exercicio26.numOpcao        = Select 1 option
teste30.exercicio26.opcao_0         = A - ConcurrentList
teste30.exercicio26.opcao_1         = B - ConcurrentArrayList
teste30.exercicio26.opcao_2         = C - CopyOnReadWriteArrayList
teste30.exercicio26.opcao_3         = D - CopyOnReadArrayList
teste30.exercicio26.opcao_4         = E - CopyOnWriteArrayList
teste30.exercicio26.questao         = Which of the following options is a thread-safe variant of ArrayList?
teste30.exercicio26.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.716.
teste30.exercicio27.ajuda.cabecalho = Use collections from the java.util.concurrent package with a focus on the advantages over and differences from the traditional java.util collections
teste30.exercicio27.ajuda.conteudo  = First Tip: If a collection changes (addition, deletion, or modification of elements) after you retrieved an iterator, it will throw a ConcurrentModificationException.\r\n\r\nSecond Tip: If a collection changes (elements are added, deleted, or modified) after the iterator is created, they don\u2019t throw any runtime exception. These iterators work with a clone of the collection rather than working with the collection itself.
teste30.exercicio27.enunExtra       = \r\n\r\nclass MyColors extends Thread {\r\n\u0009static private Map<Integer, String> map;\r\n\r\n\u0009MyColors() {\r\n\u0009\u0009// INSERT CODE HERE\r\n\u0009\u0009map.put(1, "red");\r\n\u0009\u0009map.put(2, "blue");\r\n\u0009\u0009map.put(3, "yellow");\r\n\u0009}\r\n\r\n\u0009public void iterate() {\r\n\u0009\u0009Iterator iter = map.keySet().iterator();\r\n\u0009\u0009while (iter.hasNext()) {\r\n\u0009\u0009\u0009Integer key = (Integer) iter.next();\r\n\u0009\u0009\u0009String val = (String) map.get(key);\r\n\u0009\u0009\u0009System.out.println(key + "-" + val);\r\n\u0009\u0009\u0009add(4, "green");\r\n\u0009\u0009}\r\n\u0009}\r\n\r\n\u0009public void add(Integer i, String v) {\r\n\u0009\u0009map.put(i, v);\r\n\u0009}\r\n\r\n\u0009public void run() {\r\n\u0009\u0009iterate();\r\n\u0009}\r\n}
teste30.exercicio27.numOpcao        = Select 1 option
teste30.exercicio27.opcao_0         = A - map = new HashMap<Integer, String>();
teste30.exercicio27.opcao_1         = B - map = new NoExceptionHashMap<Integer, String>();
teste30.exercicio27.opcao_2         = C - map = new ConcurrentMap<Integer, String>();
teste30.exercicio27.opcao_3         = D - map = new ConcurrentHashMap<Integer, String>();
teste30.exercicio27.opcao_4         = E - map = new CopyOnWriteHashMap<Integer, String>();
teste30.exercicio27.questao         = Which line of code, when inserted at //INSERT CODE HERE, will ensure that on execution, single or multiple MyColors instances won\u2019t throw a Concurrent-ModificationException at runtime?
teste30.exercicio27.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.716.
teste30.exercicio28.ajuda.cabecalho = Use collections from the java.util.concurrent package with a focus on the advantages over and differences from the traditional java.util collections
teste30.exercicio28.ajuda.conteudo  = Methods put() and take() of the BlockingQueue interface specify inbuilt locking support to be provided by all the implementing classes to implement the producer\u2013consumer design pattern. LinkedBlockingQueue and ArrayBlockingQueue are concrete implementations of the BlockingQueue interface.
teste30.exercicio28.enunExtra       = \ 
teste30.exercicio28.numOpcao        = Select 2 option
teste30.exercicio28.opcao_0         = A - WaitNotifyQueue
teste30.exercicio28.opcao_1         = B - BlockingQueue
teste30.exercicio28.opcao_2         = C - LinkedBlockingQueue
teste30.exercicio28.opcao_3         = D - ArrayBlockingQueue
teste30.exercicio28.opcao_4         = E - ConcurrentBlockingQueue
teste30.exercicio28.questao         = Which of the following concurrent collection classes can you use to implement the producer\u2013consumer design pattern?
teste30.exercicio28.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.713.
teste30.exercicio29.ajuda.cabecalho = Define a locale using language and country codes
teste30.exercicio29.ajuda.conteudo  = Tip: Class Locale defines the following constructors:\r\n\r\nLocale(String language)\r\nLocale(String language, String country)\r\nLocale(String language, String country, String variant)
teste30.exercicio29.enunExtra       = \ 
teste30.exercicio29.numOpcao        = Select 2 option
teste30.exercicio29.opcao_0         = A - Locale locale = new Locale();  /  locale.setLanguage("es");  /  locale.setCountry("ES");
teste30.exercicio29.opcao_1         = B - Locale locale = new Locale("es", "ES");
teste30.exercicio29.opcao_2         = C - Locale locale = new Locale("ES", "es");
teste30.exercicio29.opcao_3         = D - Locale locale = new Locale("es");
teste30.exercicio29.opcao_4         = E - None of the above
teste30.exercicio29.questao         = Given the language code for Spanish is es and the country code for Spain is ES, which of the following code options defines a Locale to work with the Spanish language?
teste30.exercicio29.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.754.
teste30.exercicio3.ajuda.cabecalho  = Override methods / Overload constructors and methods
teste30.exercicio3.ajuda.conteudo   = Tip: Class Laptop correctly overloads the method start() by defining a different parameter list.
teste30.exercicio3.enunExtra        = \r\n\r\nclass Machine {\r\n   void start() throws Exception { System.out.println("start machine"); }\r\n}\r\nclass Laptop {\r\n   void start() { System.out.println("Start Laptop"); }\r\n   void start(int ms) { System.out.println("Start Laptop:"+ms); }\r\n}
teste30.exercicio3.numOpcao         = Select 1 option
teste30.exercicio3.opcao_0          = A - Class Laptop overloads method start().
teste30.exercicio3.opcao_1          = B - Class Laptop overrides method start().
teste30.exercicio3.opcao_2          = C - Class Machine overrides method start().
teste30.exercicio3.opcao_3          = D - Class Machine won\u2019t compile.
teste30.exercicio3.opcao_4          = E - Class Laptop won\u2019t compile.
teste30.exercicio3.questao          = Examine the following code and select the answer options that are correct individually.
teste30.exercicio3.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.86.
teste30.exercicio30.ajuda.cabecalho = Read and set the locale by using the Locale object\r\nFormat dates, numbers, and currency values for localization with the Number-Format and DateFormat classes (including number format patterns)
teste30.exercicio30.ajuda.conteudo  = Tip: The output should be formatted according to Locale.UK or by using the exact pattern.
teste30.exercicio30.enunExtra       = \r\n\r\nDate today = new Date();\r\n//INSERT CODE HERE\r\nSystem.out.println(dateFmt.format(today));\r\nSystem.out.println(timeFmt.format(today));\r\n\r\nWhich of the following lines of code, when inserted at //INSERT CODE HERE, will output the date and time that coincides with the UK\u2019s Locale?\r\n\r\n21/01/09\r\n21:45:12
teste30.exercicio30.numOpcao        = Select 3 option
teste30.exercicio30.opcao_0         = A - Locale.setDefault(Locale.UK);  /  DateFormat dateFmt = DateFormat.getDateInstance (DateFormat.SHORT);\r\nDateFormat timeFmt = DateFormat.getTimeInstance (DateFormat.MEDIUM);
teste30.exercicio30.opcao_1         = B - DateFormat dateFmt = new SimpleDateFormat ("dd/MM/yy");  /  DateFormat timeFmt = new SimpleDateFormat ("HH:mm:ss");
teste30.exercicio30.opcao_2         = C - DateFormat dateFmt = DateFormat.getDateInstance (DateFormat.SHORT);\r\nDateFormat timeFmt = DateFormat.getTimeInstance (DateFormat.MEDIUM);
teste30.exercicio30.opcao_3         = D - DateFormat dateFmt = DateFormat.getDateInstance (DateFormat.SHORT, Locale.UK);\r\nDateFormat timeFmt = DateFormat.getTimeInstance (DateFormat.MEDIUM, Locale.UK);
teste30.exercicio30.opcao_4         = E - None of the above
teste30.exercicio30.questao         = Assume the following code executes on the following date and time:\r\n\r\nDate: 2009 Jan 21\r\nTime: 21:45:12
teste30.exercicio30.referencia      = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.774.
teste30.exercicio4.ajuda.cabecalho  = Use the static and final keywords / Use enumerated types
teste30.exercicio4.ajuda.conteudo   = The code compiles successfully. An enum can define and use multiple constructors. The declaration of enum constants must follow the opening brace of the enum declaration. It can\u2019t follow the definition of variables or methods.
teste30.exercicio4.enunExtra        = \r\n\r\nenum Keywords {\r\n\u0009ASSERT(1.4), // line1\r\n\u0009DO, IF, WHILE; // line2\r\n\u0009double version = 1.0; // line3\r\n\r\n\u0009Keywords() { // constructor 1\r\n\u0009\u0009this.version = 1.0; // constructor 1\r\n\u0009} // constructor 1\r\n\r\n\u0009Keywords(double version) { // constructor 2\r\n\u0009\u0009this.version = version; // constructor 2\r\n\u0009} // constructor 2\r\n\r\n\u0009public static void main(String args[]) {\r\n\u0009\u0009Keywords[] keywords = Keywords.values();\r\n\u0009\u0009for (Keywords val : keywords)\r\n\u0009\u0009\u0009System.out.println(val);\r\n\u0009}\r\n}
teste30.exercicio4.numOpcao         = Select 1 option
teste30.exercicio4.opcao_0          = A - The enum keywords won\u2019t compile due to code at (#1).
teste30.exercicio4.opcao_1          = B - The enum keywords won\u2019t compile due to code at either (#2) or (#3).
teste30.exercicio4.opcao_2          = C - If you swap the complete code at (#1) and (#2) with code at (#3), enum keywords will compile successfully.
teste30.exercicio4.opcao_3          = D - The enum keywords will fail to compile due to the declaration of multiple constructors.
teste30.exercicio4.opcao_4          = E - None of the above
teste30.exercicio4.questao          = Select the correct statement(s) based on the following code:
teste30.exercicio4.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.159.
teste30.exercicio5.ajuda.cabecalho  = Identify when and how to apply abstract classes / Construct abstract Java classes and subclasses
teste30.exercicio5.ajuda.conteudo   = Tip: When a class extends another class or implements an interface, the methods in the derived class must be either valid overloaded or valid overridden methods.
teste30.exercicio5.enunExtra        = \r\n\r\nabstract class Foo {\r\n   abstract void run();\r\n}\r\n\r\nWhich of the classes correctly subclass Foo? (Choose all that apply.)
teste30.exercicio5.numOpcao         = Select 2 option
teste30.exercicio5.opcao_0          = A - class Me extends Foo { void run() {/* ... */} }
teste30.exercicio5.opcao_1          = B - abstract class You extends Foo { void run() {/* ... */ } }
teste30.exercicio5.opcao_2          = C - interface Run { void run(); }\r\nclass Her extends Foo implements Run { void run() {/* ... */} }
teste30.exercicio5.opcao_3          = D - abstract class His extends Foo { String run() {/* ... */} }
teste30.exercicio5.opcao_4          = E - abstract class His extends Foo { Integer run() {/* ... */} }
teste30.exercicio5.questao          = Consider the following definition of class Foo:
teste30.exercicio5.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.160.
teste30.exercicio6.ajuda.cabecalho  = Use enumerated types
teste30.exercicio6.ajuda.conteudo   = Tip: ascendingValues(), naturalValues() and orderedValues() are nonexistent enum methods.
teste30.exercicio6.enunExtra        = \r\n\r\nBASKETBALL:CRICKET:TENNIS:SWIMMING:\r\n\r\nenum Sports {\r\n   TENNIS, CRICKET, BASKETBALL, SWIMMING;\r\n   public static void main(String args[]) {\r\n      // INSERT CODE HERE\r\n   }\r\n}
teste30.exercicio6.numOpcao         = Select 1 option
teste30.exercicio6.opcao_0          = A - for (Sports val:Sports.values()) System.out.print(val+":");
teste30.exercicio6.opcao_1          = B - for (Sports val:Sports.orderedValues()) System.out.print(val+":");
teste30.exercicio6.opcao_2          = C - for (Sports val:Sports.naturalValues()) System.out.print(val+":");
teste30.exercicio6.opcao_3          = D - for (Sports val:Sports.ascendingValues()) System.out.print(val+":");
teste30.exercicio6.opcao_4          = E - None of the above
teste30.exercicio6.questao          = Which lines of code, when inserted at //INSERT CODE HERE, will print the following:
teste30.exercicio6.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.03, p.160.
teste30.exercicio7.ajuda.cabecalho  = Write code that declares, implements, and/or extends interfaces
teste30.exercicio7.ajuda.conteudo   = Class EJavaGuru defines an instance variable course. Interface Online also defines a variable with the same name\u2014course (which is implicitly static). Class EJavaGuru implements Online. Using EJavaGuru\u2019s instanceName.course will refer to its instance variable. Using Online.course will refer to the variable course from Online. Using EJavaGuru.course will result in a compilation error. Code on line n1 compiles successfully and prints OCA.\r\n\r\nBecause the variables defined in an interface are implicitly static and final, the variable duration can be accessed as EJavaGuru.duration. Code on line n2 compiles successfully and prints 2.\r\n\r\nHowever, a class can\u2019t define static and instance variables with the same name. The following class won\u2019t compile:\r\n\r\nclass EJavaGuru {\r\n   String course;\r\n   static String course;\r\n}
teste30.exercicio7.enunExtra        = \r\n\r\nclass EJavaGuru implements Online {\r\n\u0009String course = "OCA";\r\n\r\n\u0009public static void main(String args[]) {\r\n\u0009\u0009EJavaGuru ejg = new EJavaGuru();\r\n\u0009\u0009System.out.print(ejg.course); // n1\r\n\u0009\u0009System.out.print(EJavaGuru.duration); // n2\r\n\u0009}\r\n}
teste30.exercicio7.numOpcao         = Select 1 option
teste30.exercicio7.opcao_0          = A - Compilation fails at line n1.
teste30.exercicio7.opcao_1          = B - Compilation fails at line n2.
teste30.exercicio7.opcao_2          = C - Code throws a runtime exception.
teste30.exercicio7.opcao_3          = D - Code prints \u201COCA2\u201D.
teste30.exercicio7.opcao_4          = E - Code prints \u201COCP2\u201D.
teste30.exercicio7.questao          = What is the output? Choose the best answer.
teste30.exercicio7.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.226.
teste30.exercicio8.ajuda.cabecalho  = Choose between interface inheritance and class inheritance
teste30.exercicio8.ajuda.conteudo   = First Tip: java.lang.Object is the base class of all classes in Java. Making class  java.lang.Object extend another class can be extremely risky. Adding a method with a particular signature can break code of some other class, if it has defined a method with the same name (defaultValue()) but a different signature that isn\u2019t compatible, forming invalid overloaded methods.\r\n\r\nSecond Tip: Creation of type SwitchArgument as an interface with method defaultValue() provides a convenient option for all existing classes that want to be passed as an argument to the switch statement. When the classes implement the interface SwitchArgument, they\u2019ll be responsible for implementing method defaultValue().
teste30.exercicio8.enunExtra        = \ 
teste30.exercicio8.numOpcao         = Select 1 option
teste30.exercicio8.opcao_0          = A - Define class SwitchArgument and make class java.lang.Object extend class SwitchArgument.
teste30.exercicio8.opcao_1          = B - Define method defaultValue in class java.lang.Object.
teste30.exercicio8.opcao_2          = C - Define interface SwitchArgument with no methods. The classes that need to be used in this switch statement \r\ncan implement interface SwitchArgument.
teste30.exercicio8.opcao_3          = D - Define interface SwitchArgument with method defaultValue(). The classes that need to be used in this switch statement \r\ncan implement interface Switch-Argument.
teste30.exercicio8.opcao_4          = E - None of the above
teste30.exercicio8.questao          = In the next Java version, designers are planning to create a new switch statement. This statement should be able to accept an object of type SwitchArgument and be able to call method  efaultValue() on it. Which of the following options describe feasible (workable) options?
teste30.exercicio8.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.02, p.226.
teste30.exercicio9.ajuda.cabecalho  = Create a generic class
teste30.exercicio9.ajuda.conteudo   = Tip: Though Java recommends using single letters like T or V to specify the type, using the letters A and B is correct in option (a) as per the syntax.
teste30.exercicio9.enunExtra        = \ 
teste30.exercicio9.numOpcao         = Select 3 option
teste30.exercicio9.opcao_0          = A - class EJavaMap<A , B> {}
teste30.exercicio9.opcao_1          = B - class EJavaMap<A a, B b> {}
teste30.exercicio9.opcao_2          = C - class EJavaMap<Aa extends String, Bb extends Object> { void add(Aa a) {} void add(Bb a) {} }
teste30.exercicio9.opcao_3          = D - class EJavaMap<Aa, Bb> { void add(Aa a, Bb b) {} }
teste30.exercicio9.opcao_4          = E - None of the above
teste30.exercicio9.questao          = Which of the following options creates a generic class that can be passed multiple generic types? (Choose all that apply.)
teste30.exercicio9.referencia       = GUPTA, Mala. OCP Java SE 7 Programmer II Certification Guide - PREPARE FOR THE 1ZO-804 EXAM. 1.ed. EUA, q.01, p.338.

teste60.exercicio1.ajuda.cabecalho  = Java Class Designer - Primitives.
teste60.exercicio1.ajuda.conteudo   = Putting 0 before a number makes that number an octal number. A decimal equivalent of 012 (in octal) is 10. If you attempt an implicit conversion from float, long, or double types (as given in options b, c, and d respectively) to an integer, you will a get compiler error.
teste60.exercicio1.enunExtra        = \r\n\r\nWhich one of the following options provides the output of this program when executed?
teste60.exercicio1.numOpcao         = Select 1 option
teste60.exercicio1.opcao_0          = A - int i = 012;
teste60.exercicio1.opcao_1          = B - int i = 10.0f;
teste60.exercicio1.opcao_2          = C - int i = 10L;
teste60.exercicio1.opcao_3          = D - int i = 10.0;
teste60.exercicio1.opcao_4          = E - None of the Above.
teste60.exercicio1.questao          = Consider the following code snippet:\r\n\r\nif(i == 10.0)\r\n    System.out.println("true");\r\n\r\nWhich one of the following declarations of the variable i will compile without errors and print true when the program executes?
teste60.exercicio1.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.01, p.513.
teste60.exercicio10.ajuda.cabecalho = Java Class Designer
teste60.exercicio10.ajuda.conteudo  = Number is an abstract class, hence you cannot instantiate it using new operator. Many classes including Integer, Float, and BigDecimal derive from the Number class.
teste60.exercicio10.enunExtra       = \ \r\n\r\nWhich one of the following options correctly describes the behavior of this program?
teste60.exercicio10.numOpcao        = Select 1 option
teste60.exercicio10.opcao_0         = A - Compiler error in line marked with comment NUM because Number cannot be instantiated.
teste60.exercicio10.opcao_1         = B - Compiler error in line marked with comment BIG because BigDecimal does not inherit from Number.
teste60.exercicio10.opcao_2         = C - When executed, this program prints the following: 0 1 2.0 3.
teste60.exercicio10.opcao_3         = D - When executed, this program prints the following: 0.0 1.0 2.0 3.0.
teste60.exercicio10.opcao_4         = E - None of the Above.
teste60.exercicio10.questao         = Consider the following program:\r\n\r\nimport java.math.BigDecimal;\r\n\r\nclass NumberTest {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Number[] numbers = new Number[4];\r\n\u0009\u0009numbers[0] = new Number(0); // NUM\r\n\u0009\u0009numbers[1] = new Integer(1);\r\n\u0009\u0009numbers[2] = new Float(2.0f);\r\n\u0009\u0009numbers[3] = new BigDecimal(3.0); // BIG\r\n\u0009\u0009for (Number num : numbers) {\r\n\u0009\u0009\u0009System.out.print(num + " ");\r\n\u0009\u0009}\r\n\u0009}\r\n\r\n\u0009}
teste60.exercicio10.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.02, p.513.
teste60.exercicio11.ajuda.cabecalho = String and StringBuilder
teste60.exercicio11.ajuda.conteudo  = The method StringBuffer replace(int start, int end, String str) has the following behavior according to the Javadoc that explains the behavior of this code segment: \u201CReplaces the characters in a substring of this sequence with characters in the specified String. The substring begins at the specified start and extends to the character at index end - 1 or to the end of the sequence if no such character exists. First, the characters in the substring are removed and then the specified String is inserted at the start. (This sequence will be lengthened to accommodate the specified String if necessary.)\u201D
teste60.exercicio11.enunExtra       = \r\n\r\nWhich one of the following options correctly describes the behavior of this code segment?
teste60.exercicio11.numOpcao        = Select 1 option
teste60.exercicio11.opcao_0         = A - This code segment: This, that, etc, etcetera.!
teste60.exercicio11.opcao_1         = B - This code segment: This, that, etcetera!
teste60.exercicio11.opcao_2         = C - This code segment: This, that, etc.
teste60.exercicio11.opcao_3         = D - This program throws in an ArrayIndexOutOfBoundsException.
teste60.exercicio11.opcao_4         = E - This code segment: This, that, etcetera.!
teste60.exercicio11.questao         = Consider the following code segment:\r\n\r\nStringBuffer strBuffer = new StringBuffer("This, that, etc.!");\r\nSystem.out.println(strBuffer.replace(12, 15, "etcetera"));
teste60.exercicio11.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.03, p.514.
teste60.exercicio12.ajuda.cabecalho = Exceptions in Java.
teste60.exercicio12.ajuda.conteudo  = The call new StringBuffer(10); creates a StringBuffer object with initial capacity to store 10 characters; this capacity would grow as you keep calling methods like append().\r\nAfter the calls to append \u201Chello\u201D and \u201Cworld ,\u201D the call to append null results in adding the string \u201Cnull\u201D to the string buffer (it doesn\u2019t result in a NullPointerException or InvalidArgumentException). With the append of \u201Cnull,\u201D the capacity of the string buffer has grown to 17 characters. So, the call strBuffer.insert(11, '!'); successfully inserts the character \u2018!\u2019 in the 11th position instead of resulting in an ArrayIndexOutOfBoundsException.
teste60.exercicio12.enunExtra       = \r\n\r\nWhich one of the following options correctly describes the behavior of this program?
teste60.exercicio12.numOpcao        = Select 1 option
teste60.exercicio12.opcao_0         = A - This program prints the following: hello world!
teste60.exercicio12.opcao_1         = B - This program prints the following: hello world! null
teste60.exercicio12.opcao_2         = C - This program throws a NullPointerException.
teste60.exercicio12.opcao_3         = D - This program throws an InvalidArgumentException.
teste60.exercicio12.opcao_4         = E - This program throws an ArrayIndexOutOfBoundsException.
teste60.exercicio12.questao         = Consider the following program:\r\n\r\nclass SBAppend {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Object nullObj = null;\r\n\u0009\u0009StringBuffer strBuffer = new StringBuffer(10);\r\n\u0009\u0009strBuffer.append("hello ");\r\n\u0009\u0009strBuffer.append("world ");\r\n\u0009\u0009strBuffer.append(nullObj);\r\n\u0009\u0009strBuffer.insert(11, '!');\r\n\u0009\u0009System.out.println(strBuffer);\r\n\u0009}\r\n}
teste60.exercicio12.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.04, p.514.
teste60.exercicio13.ajuda.cabecalho = Exceptions in Java.
teste60.exercicio13.ajuda.conteudo  = Note that unboxing can take place in expressions when you use a wrapper type object in place of a primitive type value. In this case, in the condition check for the conditional operator (?: operator), a primitive boolean value is required, but a wrapper type object is provided. \r\nHence auto-unboxing occurs, with the reference pointing to null. As a result, this code segment results in throwing a NullPointerException.
teste60.exercicio13.enunExtra       = \r\n\r\nWhich one of the following options correctly describes the behavior of this code segment?
teste60.exercicio13.numOpcao        = Select 1 option
teste60.exercicio13.opcao_0         = A - This code will result in a compiler error since a reference type (of type Boolean) cannot be used \r\nas part of expression for condition check.
teste60.exercicio13.opcao_1         = B - This code will result in a throwing a NullPointerException.
teste60.exercicio13.opcao_2         = C - This code will print true in console.
teste60.exercicio13.opcao_3         = D - This code will print false in console.
teste60.exercicio13.opcao_4         = E - None of the Above.
teste60.exercicio13.questao         = Consider the following code segment:\r\n\r\nBoolean b = null;\r\nSystem.out.println(b ? true : false);
teste60.exercicio13.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.05, p.514.
teste60.exercicio14.ajuda.cabecalho = Inheritance and Polimorphism
teste60.exercicio14.ajuda.conteudo  = Whenever a class gets instantiated, the constructor of its base classes (the constructor of the root of the hierarchy gets executed first) gets invoked before the constructor of the instantiated class.
teste60.exercicio14.enunExtra       = \ 
teste60.exercicio14.numOpcao        = Select 1 option
teste60.exercicio14.opcao_0         = A - Base  /  Derived  /  DeriDerived
teste60.exercicio14.opcao_1         = B - Derived  /  DeriDerived
teste60.exercicio14.opcao_2         = C - DeriDerived  /  Derived  /  Base
teste60.exercicio14.opcao_3         = D - DeriDerived  /  Derived
teste60.exercicio14.opcao_4         = E - None of the Above.
teste60.exercicio14.questao         = What will be the output of the following program?\r\n\r\nclass Base {\r\n\u0009public Base() {\r\n\u0009\u0009System.out.println("Base");\r\n\u0009}\r\n}\r\n\r\nclass Derived extends Base {\r\n\u0009public Derived() {\r\n\u0009\u0009System.out.println("Derived");\r\n\u0009}\r\n}\r\n\r\nclass DeriDerived extends Derived {\r\n\u0009public DeriDerived() {\r\n\u0009\u0009System.out.println("DeriDerived");\r\n\u0009}\r\n}\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Derived b = new DeriDerived();\r\n\u0009}\r\n}
teste60.exercicio14.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.06, p.515.
teste60.exercicio15.ajuda.cabecalho = Access Modifiers
teste60.exercicio15.ajuda.conteudo  = Only public, abstract, and final modifiers are permitted for an outer class; using private, protected, or static will result in a compiler error.
teste60.exercicio15.enunExtra       = \ 
teste60.exercicio15.numOpcao        = Select 3 options
teste60.exercicio15.opcao_0         = A - public
teste60.exercicio15.opcao_1         = B - protected
teste60.exercicio15.opcao_2         = C - private
teste60.exercicio15.opcao_3         = D - abstract
teste60.exercicio15.opcao_4         = E - final
teste60.exercicio15.questao         = Consider the following code segment:\r\n\r\nMODIFIER class SomeClass { }\r\n\r\nWhich three of the following modifiers, when replaced instead of MODIFIER, will compile cleanly?
teste60.exercicio15.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.07, p.516.
teste60.exercicio16.ajuda.cabecalho = Constructors - Super and This.
teste60.exercicio16.ajuda.conteudo  = Tip: You cannot refer to an instance field x while explicitly invoking a constructor using this keyword.
teste60.exercicio16.enunExtra       = \r\n\r\nWhich one of the following definitions of the Point constructor can be replaced without compiler errors in place of the comment DEFAULT_CTOR?
teste60.exercicio16.numOpcao        = Select 1 option
teste60.exercicio16.opcao_0         = A - public Point() { this(0, 0); super(); }
teste60.exercicio16.opcao_1         = B - public Point() { super(); this(0, 0); }
teste60.exercicio16.opcao_2         = C - private Point() { this(0, 0); }
teste60.exercicio16.opcao_3         = D - public Point() { this(); }
teste60.exercicio16.opcao_4         = E - public Point() { this(x, 0); }
teste60.exercicio16.questao         = Consider the following class definition:\r\n\r\nclass Point {\r\n\u0009private int x = 0, y;\r\n\r\n\u0009public Point(int x, int y) {\r\n\u0009\u0009this.x = x;\r\n\u0009\u0009this.y = y;\r\n\u0009}\r\n\u0009// DEFAULT_CTOR\r\n}
teste60.exercicio16.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.08, p.516.
teste60.exercicio17.ajuda.cabecalho = Constructors
teste60.exercicio17.ajuda.conteudo  = If you remove Stmt-1, a call to super(s) will result in printing Base: Hello, and then constructor of the Derived class invocation will print Derived. \r\nSimilarly, removal of Stmt-2 will also produce the correct program. In fact, if you remove both these statements, you will also get a compilable program.
teste60.exercicio17.enunExtra       = \r\n\r\nSelect three correct options from the following list:
teste60.exercicio17.numOpcao        = Select 3 options
teste60.exercicio17.opcao_0         = A - Removing Stmt-1 will make the program compilable and it will print the following: Base Derived.
teste60.exercicio17.opcao_1         = B - Removing Stmt-1 will make the program compilable and it will print the following: Base: Hello Derived.
teste60.exercicio17.opcao_2         = C - Removing Stmt-2 will make the program compilable and it will print the following: Base Derived.
teste60.exercicio17.opcao_3         = D - Removing both Stmt-1 and Stmt-2 will make the program compilable and it will print the following: Base Derived.
teste60.exercicio17.opcao_4         = E - Removing both Stmt-1 and Stmt-2 will make the program compilable and it will print the following: Base: Hello Derived.
teste60.exercicio17.questao         = Consider the following program:\r\n\r\nclass Base {\r\n\u0009public Base() {\r\n\u0009\u0009System.out.print("Base ");\r\n\u0009}\r\n\r\n\u0009public Base(String s) {\r\n\u0009\u0009System.out.print("Base: " + s);\r\n\u0009}\r\n}\r\n\r\nclass Derived extends Base {\r\n\u0009public Derived(String s) {\r\n\u0009\u0009super(); // Stmt-1\r\n\u0009\u0009super(s); // Stmt-2\r\n\u0009\u0009System.out.print("Derived ");\r\n\u0009}\r\n}\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Base a = new Derived("Hello ");\r\n\u0009}\r\n}
teste60.exercicio17.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.09, p.517.
teste60.exercicio18.ajuda.cabecalho = Static imports
teste60.exercicio18.ajuda.conteudo  = \ Tip: You can import an individual static member of a class or all its static members by using the import static statement.
teste60.exercicio18.enunExtra       = \ 
teste60.exercicio18.numOpcao        = Select 1 option
teste60.exercicio18.opcao_0         = A - static import abc.org.project.A;
teste60.exercicio18.opcao_1         = B - static import abc.org.project.A.MYCONST;
teste60.exercicio18.opcao_2         = C - import static abc.org.project.A;
teste60.exercicio18.opcao_3         = D - import static abc.org.project.A.MYCONST;
teste60.exercicio18.opcao_4         = E - None of the Above.
teste60.exercicio18.questao         = You want to use the static member MYCONST belonging to class A in abc.org.project package. Which one of the following statements shows the correct use of static import feature?
teste60.exercicio18.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.10, p.517.
teste60.exercicio19.ajuda.cabecalho = Imports
teste60.exercicio19.ajuda.conteudo  = The member out is a static member in the System class; you can statically import it and call println method on it. Note that println is a non-static member. Also, the statement import static java.lang.System.out.*; will result in a compiler error since out is not a class (but a static member of type PrintStream).
teste60.exercicio19.enunExtra       = \ 
teste60.exercicio19.numOpcao        = Select 1 option
teste60.exercicio19.opcao_0         = A - import static java.lang.System.out.println; class StaticImport { public static void main(String []args) \r\n{ println("hello world"); } }
teste60.exercicio19.opcao_1         = B - import static java.lang.System.out; class StaticImport { public static void main(String []args) \r\n{ out.println("hello world"); } }
teste60.exercicio19.opcao_2         = C - import static java.lang.System.out.*; class StaticImport { public static void main(String []args) { out.println("hello world"); } }
teste60.exercicio19.opcao_3         = D - import static java.lang.System.out.*; class StaticImport { public static void main(String []args) { println("hello world"); } }
teste60.exercicio19.opcao_4         = E - None of the Above.
teste60.exercicio19.questao         = Which one of the following programs compiles without any errors and prints \u201Chello world\u201D in console?
teste60.exercicio19.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.11, p.518.
teste60.exercicio2.ajuda.cabecalho  = Inheritance
teste60.exercicio2.ajuda.conteudo   = Statement #1 will result in a compiler error since the keyword protected is not allowed inside a method body.
teste60.exercicio2.enunExtra        = \ 
teste60.exercicio2.numOpcao         = Select 1 option
teste60.exercicio2.opcao_0          = A - The compiler will report an error at statement #1.
teste60.exercicio2.opcao_1          = B - The compiler will report an error at statement #2.
teste60.exercicio2.opcao_2          = C - The compiler will report errors at statement #3.
teste60.exercicio2.opcao_3          = D - The program will compile without any error.
teste60.exercicio2.opcao_4          = E - None of the Above.
teste60.exercicio2.questao          = Consider the following program and choose the right option from the given list:\r\n\r\nclass Base {\r\n\u0009public void test() {\r\n\u0009\u0009protected int a = 10; // #1\r\n\u0009}\r\n}\r\n\r\nclass Test extends Base { // #2\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009System.out.printf(null); // #3\r\n\u0009}\r\n}
teste60.exercicio2.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.12, p.518.
teste60.exercicio20.ajuda.cabecalho = Inheritance and Casts.
teste60.exercicio20.ajuda.conteudo  = The dynamic type of variable obj is Base1 that you were trying to cast into Base2. This is not supported and so results in an exception.
teste60.exercicio20.enunExtra       = \ 
teste60.exercicio20.numOpcao        = Select 1 option
teste60.exercicio20.opcao_0         = A - The program will print the following: Base1.
teste60.exercicio20.opcao_1         = B - The program will print the following: Base2.
teste60.exercicio20.opcao_2         = C - The compiler will report an error in the line marked with comment CAST.
teste60.exercicio20.opcao_3         = D - The program will result in an exception (ClassCastException).
teste60.exercicio20.opcao_4         = E - None of the Above.
teste60.exercicio20.questao         = Consider the following program and choose the correct option from the list of options:\r\n\r\nclass Base {\r\n\u0009public void test() {\r\n\u0009}\r\n}\r\n\r\nclass Base1 extends Base {\r\n\u0009public void test() {\r\n\u0009\u0009System.out.println("Base1");\r\n\u0009}\r\n}\r\n\r\nclass Base2 extends Base {\r\n\u0009public void test() {\r\n\u0009\u0009System.out.println("Base2");\r\n\u0009}\r\n}\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Base obj = new Base1();\r\n\u0009\u0009((Base2) obj).test(); // CAST\r\n\u0009}\r\n}
teste60.exercicio20.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.13, p.519.
teste60.exercicio21.ajuda.cabecalho = Inner classes
teste60.exercicio21.ajuda.conteudo  = An inner class can access even the private members of the outer class. Similarly, the private variable belonging to the inner class can be accessed in the outer class.
teste60.exercicio21.enunExtra       = \ \r\n\r\nWhich one of the following statements will you replace in place of // Stmt#1 to make the program compile and run successfully to print \u201CInner: print\u201D in console?
teste60.exercicio21.numOpcao        = Select 1 option
teste60.exercicio21.opcao_0         = A - Outer.Inner inner = new Outer.Inner();
teste60.exercicio21.opcao_1         = B - Inner inner = new Outer.Inner();
teste60.exercicio21.opcao_2         = C - Outer.Inner inner = new Outer().Inner();
teste60.exercicio21.opcao_3         = D - Outer.Inner inner = new Outer().new Inner();
teste60.exercicio21.opcao_4         = E - None of the Above.
teste60.exercicio21.questao         = Consider the following program:\r\n\r\nclass Outer {\r\n\u0009class Inner {\r\n\u0009\u0009public void print() {\r\n\u0009\u0009\u0009System.out.println("Inner: print");\r\n\u0009\u0009}\r\n\u0009}\r\n}\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009// Stmt#1\r\n\u0009\u0009inner.print();\r\n\u0009}\r\n}
teste60.exercicio21.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.14, p.519.
teste60.exercicio22.ajuda.cabecalho = Inner classes
teste60.exercicio22.ajuda.conteudo  = An inner class can access even the private members of the outer class. Similarly, the private variable belonging to the inner class can be accessed in the outer class.
teste60.exercicio22.enunExtra       = \r\n\r\nWhich one of the following options is correct?
teste60.exercicio22.numOpcao        = Select 1 option
teste60.exercicio22.opcao_0         = A - When compiled, this program will result in a compiler error in line marked with comment ACCESS1.
teste60.exercicio22.opcao_1         = B - When compiled, this program will result in a compiler error in line marked with comment ACCESS2.
teste60.exercicio22.opcao_2         = C - When executed, this program prints 10.
teste60.exercicio22.opcao_3         = D - When executed, this program prints 0.
teste60.exercicio22.opcao_4         = E - None of the Above.
teste60.exercicio22.questao         = Consider the following program:\r\n\r\npublic class Outer {\r\n\u0009private int mem = 10;\r\n\r\n\u0009class Inner {\r\n\u0009\u0009private int imem = new Outer().mem; // ACCESS1\r\n\u0009}\r\n\r\n\u0009public static void main(String[] s) {\r\n\u0009\u0009System.out.println(new Outer().new Inner().imem); // ACCESS2\r\n\u0009}\r\n}\r\n
teste60.exercicio22.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.15, p.520.
teste60.exercicio23.ajuda.cabecalho = Interfaces and instanceof
teste60.exercicio23.ajuda.conteudo  = An enumeration can implement an interface (but cannot extend a class, or cannot be a base class).\r\nEach enumeration constant is an object of its enumeration type. An enumeration automatically extends the abstract class java.util.Enum. Hence, all the three instanceof checks succeed.
teste60.exercicio23.enunExtra       = \r\n\r\nWhich one of the following options is correct?
teste60.exercicio23.numOpcao        = Select 1 option
teste60.exercicio23.opcao_0         = A - This program results in a compiler in the line marked with comment IMPLEMENTS_INTERFACE.
teste60.exercicio23.opcao_1         = B - This program results in a compiler in the line marked with comment THIRD_CHECK.
teste60.exercicio23.opcao_2         = C - When executed, this program prints the following: yes, instance of AnEnum
teste60.exercicio23.opcao_3         = D - When executed, this program prints the following: yes, instance of AnEnum  /  yes, instance of EnumBase
teste60.exercicio23.opcao_4         = E - When executed, this program prints the following: yes, instance of AnEnum  /  yes, instance of EnumBase  /  \r\nyes, instance of Enum
teste60.exercicio23.questao         = Consider the following program:\r\n\r\ninterface EnumBase {\r\n}\r\n\r\nenum AnEnum implements EnumBase { // IMPLEMENTS_INTERFACE\r\n\u0009ONLY_MEM;\r\n}\r\n\r\nclass EnumCheck {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009if (AnEnum.ONLY_MEM instanceof AnEnum) {\r\n\u0009\u0009\u0009System.out.println("yes, instance of AnEnum");\r\n\u0009\u0009}\r\n\u0009\u0009if (AnEnum.ONLY_MEM instanceof EnumBase) {\r\n\u0009\u0009\u0009System.out.println("yes, instance of EnumBase");\r\n\u0009\u0009}\r\n\u0009\u0009if (AnEnum.ONLY_MEM instanceof Enum) { // THIRD_CHECK\r\n\u0009\u0009\u0009System.out.println("yes, instance of Enum");\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio23.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.16, p.520.
teste60.exercicio24.ajuda.cabecalho = Enumerated types
teste60.exercicio24.ajuda.conteudo  = Think of the courses offered by a university or maybe even the roles within an organization: each defines a finite and predefined set of objects. These finite and predefined sets of objects can be defined as enumerated types, or enums. An enum defines a new custom data type (like interfaces and classes). Users are allowed to use only existing enum objects; they can\u2019t create new enum objects.
teste60.exercicio24.enunExtra       = \ 
teste60.exercicio24.numOpcao        = Select 3 options
teste60.exercicio24.opcao_0         = A - An enum can have private constructor.
teste60.exercicio24.opcao_1         = B - An enum can have public constructor.
teste60.exercicio24.opcao_2         = C - An enum can have public methods and fields.
teste60.exercicio24.opcao_3         = D - An enum can implement an interface.
teste60.exercicio24.opcao_4         = E - An enum can extend a class.
teste60.exercicio24.questao         = Which of the following statements are true with respect to enums? (Select all that apply.)
teste60.exercicio24.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.17, p.521.
teste60.exercicio25.ajuda.cabecalho = Interfaces and Inheritance
teste60.exercicio25.ajuda.conteudo  = Statement #1 and #2 will not raise any alarm; only access to the variable var will generate an error since the access is ambiguous (since the variable is declared in both base1 and base2).
teste60.exercicio25.enunExtra       = \ 
teste60.exercicio25.numOpcao        = Select 1 option
teste60.exercicio25.opcao_0         = A - The program will report a compilation error at statement #1.
teste60.exercicio25.opcao_1         = B - The program will report a compilation error at statement #2.
teste60.exercicio25.opcao_2         = C - The program will report a compilation error at statement #3.
teste60.exercicio25.opcao_3         = D - The program will compile without any errors.
teste60.exercicio25.opcao_4         = E - None of the Above.
teste60.exercicio25.questao         = Consider the following program and predict the behavior:\r\n\r\nclass base1 {\r\n\u0009protected int var;\r\n}\r\n\r\ninterface base2 {\r\n\u0009int var = 0; // #1\r\n}\r\n\r\nclass Test extends base1 implements base2 { // #2\r\n\u0009public static void main(String args[]) {\r\n\u0009\u0009System.out.println("var:" + var); // #3\r\n\u0009}\r\n}
teste60.exercicio25.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.18, p.521.
teste60.exercicio26.ajuda.cabecalho = Interfaces
teste60.exercicio26.ajuda.conteudo  = First Tip: For the substitution to succeed, the type substituted for the wildcard? should be DI or one of its super types.\r\n\r\nSecond Tip: The type argument is not provided, meaning that C is a raw type in the expression new C(). Hence, this will elicit a compiler warning, but not an error.
teste60.exercicio26.enunExtra       = \ 
teste60.exercicio26.numOpcao        = Select 1 option
teste60.exercicio26.opcao_0         = A - Line marked with comment ONE will result in a compiler error.
teste60.exercicio26.opcao_1         = B - Line marked with comment TWO will result in a compiler error.
teste60.exercicio26.opcao_2         = C - Line marked with comment THREE will result in a compiler error.
teste60.exercicio26.opcao_3         = D - Line marked with comment FOUR will result in a compiler error.
teste60.exercicio26.opcao_4         = E - None of the Above.
teste60.exercicio26.questao         = Consider the following program:\r\n\r\nclass WildCard {\r\n\u0009interface BI {\r\n\u0009}\r\n\r\n\u0009interface DI extends BI {\r\n\u0009}\r\n\r\n\u0009interface DDI extends DI {\r\n\u0009}\r\n\r\n\u0009static class C<T> {\r\n\u0009}\r\n\r\n\u0009static void foo(C<? super DI> arg) {\r\n\u0009}\r\n\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009foo(new C<BI>()); // ONE\r\n\u0009\u0009foo(new C<DI>()); // TWO\r\n\u0009\u0009foo(new C<DDI>()); // THREE\r\n\u0009\u0009foo(new C()); // FOUR\r\n\u0009}\r\n}
teste60.exercicio26.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.19, p.522.
teste60.exercicio27.ajuda.cabecalho = Generics and Inheritance
teste60.exercicio27.ajuda.conteudo  = The keyword extends is used to specify the upper bound for type T; with this, only the classes or interfaces implementing the interface DI can be used as a replacement for T. Note that the extends keyword is used for any base type\u2014irrespective of if the base type is a class or an interface.
teste60.exercicio27.enunExtra       = \r\n\r\nThe following options provide definitions of a template class X. Which one of the options specifies class X with a type parameter whose upper bound declares DI to be the super type from which all type arguments must be derived?
teste60.exercicio27.numOpcao        = Select 1 option
teste60.exercicio27.opcao_0         = A - class X <T super DI> { }
teste60.exercicio27.opcao_1         = B - class X <T implements DI> { }
teste60.exercicio27.opcao_2         = C - D - class X <T extends ? || DI> { }
teste60.exercicio27.opcao_3         = D - class X <T extends ? & DI> { }
teste60.exercicio27.opcao_4         = E - class X <T extends DI> { }
teste60.exercicio27.questao         = Consider the following definitions:\r\n\r\ninterface BI {}\r\ninterface DI extends BI {}
teste60.exercicio27.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.20, p.522.
teste60.exercicio28.ajuda.cabecalho = Interfaces and Inheritance
teste60.exercicio28.ajuda.conteudo  = You can extend from only one base class (since Java does not support multiple class inheritance). However, you can implement multiple interfaces; in that case, the list of implemented interfaces is separated by commas.
teste60.exercicio28.enunExtra       = \r\n\r\nWhich one of the following statements will compile without errors if replaced in place of the line\r\nmarked with comment Stmt?
teste60.exercicio28.numOpcao        = Select 1 option
teste60.exercicio28.opcao_0         = A - class Test extends base1, base2 implements base3, base4 {
teste60.exercicio28.opcao_1         = B - class Test extends base1 implements base3, base4 {
teste60.exercicio28.opcao_2         = C - class Test extends base1 implements base3 implements base4 {
teste60.exercicio28.opcao_3         = D - class Test extends base1, extends base2 implements base3, base4 {
teste60.exercicio28.opcao_4         = E - None of the Above.
teste60.exercicio28.questao         = Consider the following program:\r\n\r\nclass base1{}\r\nclass base2{}\r\ninterface base3{}\r\ninterface base4{}\r\n// Stmt\r\npublic static void main(String args[]){\r\n    }\r\n}
teste60.exercicio28.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.21, p.522.
teste60.exercicio29.ajuda.cabecalho = Singleton pattern
teste60.exercicio29.ajuda.conteudo  = A Factory class generates the desired type of objects on demand. Hence, it might be required that only one Factory object exists; in this case, Singleton can be employed in a Factory class.
teste60.exercicio29.enunExtra       = \ 
teste60.exercicio29.numOpcao        = Select 1 option
teste60.exercicio29.opcao_0         = A - A Singleton class must not have any static members.
teste60.exercicio29.opcao_1         = B - A Singleton class has a public constructor.
teste60.exercicio29.opcao_2         = C - A Factory class may use Singleton pattern.
teste60.exercicio29.opcao_3         = D - All methods of the Singleton class must be private.
teste60.exercicio29.opcao_4         = E - None of the Above.
teste60.exercicio29.questao         = In the context of Singleton pattern, which one of the following statements is true?
teste60.exercicio29.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.22, p.523.
teste60.exercicio3.ajuda.cabecalho  = DAO pattern
teste60.exercicio3.ajuda.conteudo   = The DAO pattern separates the persistence logic from the rest of the business logic. In this pattern, TransferObject is a role played by an object that needs to be stored on a persistent medium. Here, only the Image class fits the description of a TransferObject.
teste60.exercicio3.enunExtra        = \ 
teste60.exercicio3.numOpcao         = Select 1 option
teste60.exercicio3.opcao_0          = A - ImageManager
teste60.exercicio3.opcao_1          = B - ImageFactory
teste60.exercicio3.opcao_2          = C - Image
teste60.exercicio3.opcao_3          = D - ImageProcessor
teste60.exercicio3.opcao_4          = E - None of the Above.
teste60.exercicio3.questao          = In the context of DAO pattern, which one of the following classes could be playing a role of TransferObject:
teste60.exercicio3.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.23, p.523.
teste60.exercicio30.ajuda.cabecalho = List
teste60.exercicio30.ajuda.conteudo  = The getContents() method is declared in ListResourceBundle as follows:\r\n\r\nprotected abstract Object[][] getContents()\r\n\r\nThe other three definitions are incorrect overrides and will result in compiler error(s).
teste60.exercicio30.enunExtra       = \ 
teste60.exercicio30.numOpcao        = Select 1 option
teste60.exercicio30.opcao_0         = A - public String[][] getContents() { return new Object[][] { { "1", "Uno" }, { "2", "Duo" }, { "3", "Trie" }}; }
teste60.exercicio30.opcao_1         = B - public Object[][] getContents() { return new Object[][] { { "1", "Uno" }, { "2", "Duo" }, { "3", "Trie" }}; }
teste60.exercicio30.opcao_2         = C - private List<String> getContents() { return new ArrayList (Arrays.AsList({ { "1", "Uno" }, { "2", "Duo" }, { "3", "Trie" }}); }
teste60.exercicio30.opcao_3         = D - protected Object[] getContents() { return new String[] { "Uno", "Duo", "Trie" }; }
teste60.exercicio30.opcao_4         = E - None of the Above.
teste60.exercicio30.questao         = In a class that extends ListResourceBundle, which one of the following method definitions correctly overrides the getObject() method of the base class?
teste60.exercicio30.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.30, p.526.
teste60.exercicio31.ajuda.cabecalho = Iterator
teste60.exercicio31.ajuda.conteudo  = The interface Iterable<T> declares this single method:\r\n\r\nIterator<T> iterator();\r\n\r\nThis iterator() method returns an object of type Iterator<T>. A class must implement Iterable<T> for using its object in a for-each loop.
teste60.exercicio31.enunExtra       = \ 
teste60.exercicio31.numOpcao        = Select 1 option
teste60.exercicio31.opcao_0         = A - Iterable<T>
teste60.exercicio31.opcao_1         = B - Iterator<T>
teste60.exercicio31.opcao_2         = C - Enumeration<E>
teste60.exercicio31.opcao_3         = D - ForEach<T>
teste60.exercicio31.opcao_4         = E - None of the Above.
teste60.exercicio31.questao         = Which one of the following interfaces declares a single method named iterator()? (Note: Implementing this interface allows an object to be the target of the for-each statement.)
teste60.exercicio31.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.31, p.526.
teste60.exercicio32.ajuda.cabecalho = Threads
teste60.exercicio32.ajuda.conteudo  = java.lang.Math.random() is not efficient for concurrent programs. Using ThreadLocalRandom results in less overhead and contention when compared to using Random objects in concurrent programs (and hence using this class type is the best option in this case).\r\njava.util.RandomAccess is unrelated to random number generation. This interface is the base interface for random access data structures and is implemented by classes such as Vector and ArrayList. java.lang.ThreadLocal<T> class provides support for creating thread-local variables.
teste60.exercicio32.enunExtra       = \ 
teste60.exercicio32.numOpcao        = Select 1 option
teste60.exercicio32.opcao_0         = A - Using java.lang.Math.random()
teste60.exercicio32.opcao_1         = B - Using java.util.concurrent.ThreadLocalRandom
teste60.exercicio32.opcao_2         = C - Using java.util.RandomAccess
teste60.exercicio32.opcao_3         = D - Using java.lang.ThreadLocal<T>
teste60.exercicio32.opcao_4         = E - None of the Above.
teste60.exercicio32.questao         = Which one of the following options is best suited for generating random numbers in a multi-threaded application?
teste60.exercicio32.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.32, p.526.
teste60.exercicio33.ajuda.cabecalho = Generics and Lists
teste60.exercicio33.ajuda.conteudo  = In the asList2 method definition, temp is declared as ArrayList<?>. Since the template type is a wild-card, you cannot put any element (or modify the container). Hence, the method call temp.add(element); will result in a compiler error.
teste60.exercicio33.enunExtra       = \r\n\r\nWhich of the asList definitions in this program will result in a compiler error?
teste60.exercicio33.numOpcao        = Select 1 option
teste60.exercicio33.opcao_0         = A - The definition of asList1 will result in a compiler error.
teste60.exercicio33.opcao_1         = B - The definition of asList2 will result in a compiler error.
teste60.exercicio33.opcao_2         = C - The definition of asList3 will result in a compiler error.
teste60.exercicio33.opcao_3         = D - The definition of asList4 will result in a compiler error.
teste60.exercicio33.opcao_4         = E - None of the definitions (asList1, asList2, asList3, asList4) will result in a compiler error.
teste60.exercicio33.questao         = Consider the following program:\r\n\r\nimport java.util.*;\r\n\r\nclass ListFromVarargs {\r\n\u0009public static <T> List<T> asList1(T... elements) {\r\n\u0009\u0009ArrayList<T> temp = new ArrayList<>();\r\n\u0009\u0009for (T element : elements) {\r\n\u0009\u0009\u0009temp.add(element);\r\n\u0009\u0009}\r\n\u0009\u0009return temp;\r\n\u0009}\r\n\r\n\u0009public static <T> List<?> asList2(T... elements) {\r\n\u0009\u0009ArrayList<?> temp = new ArrayList<>();\r\n\u0009\u0009for (T element : elements) {\r\n\u0009\u0009\u0009temp.add(element);\r\n\u0009\u0009}\r\n\u0009\u0009return temp;\r\n\u0009}\r\n\r\n\u0009public static <T> List<?> asList3(T... elements) {\r\n\u0009\u0009ArrayList<T> temp = new ArrayList<>();\r\n\u0009\u0009for (T element : elements) {\r\n\u0009\u0009\u0009temp.add(element);\r\n\u0009\u0009}\r\n\u0009\u0009return temp;\r\n\u0009}\r\n\r\n\u0009public static <T> List<?> asList4(T... elements) {\r\n\u0009\u0009List<T> temp = new ArrayList<T>();\r\n\u0009\u0009for (T element : elements) {\r\n\u0009\u0009\u0009temp.add(element);\r\n\u0009\u0009}\r\n\u0009\u0009return temp;\r\n\u0009}\r\n}
teste60.exercicio33.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.33, p.526.
teste60.exercicio34.ajuda.cabecalho = Date
teste60.exercicio34.ajuda.conteudo  = Class java.text.SimpleDateFormat allows you to define custom patterns for processing date and time for specific locales.
teste60.exercicio34.enunExtra       = \ 
teste60.exercicio34.numOpcao        = Select 3 options
teste60.exercicio34.opcao_0         = A - java.text.Format is the abstract base class that supports formatting of locale sensitive information \r\nsuch as date, time, and currency
teste60.exercicio34.opcao_1         = B - java.text.CustomTimeFormat allows you to define custom patterns for processing time for specific locales.
teste60.exercicio34.opcao_2         = C - java.text.NumberFormat derives from the java.text.Format class; it is the base class for processing numbers, \r\ncurrency, etc. in a locale sensitive way.
teste60.exercicio34.opcao_3         = D - java.text.DateFormat derives from the java.text.Format class; it is the base class for processing date and \r\ntime information based on locale.
teste60.exercicio34.opcao_4         = E - None of the Above.
teste60.exercicio34.questao         = Which of the following statements are true about classes relating to formatting date and time for local cultures? (select all that apply)
teste60.exercicio34.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.40, p.530.
teste60.exercicio35.ajuda.cabecalho = Map and Hashmap
teste60.exercicio35.ajuda.conteudo  = Due to the diamond syntax, it is optional to specify template types in the right hand side of an object creation statement. Hence, statement #3 is right. Statement #2 is correct since HashMap is a Map. \r\nIn statement #1, the order of arguments of the declared type is different from the order of arguments in the initialized type. In statement #4, the diamond syntax is used in the declaration of the type and so is incorrect (the correct way is to use the diamond operator in the initialization type).
teste60.exercicio35.enunExtra       = \ 
teste60.exercicio35.numOpcao        = Select 1 option
teste60.exercicio35.opcao_0         = A - Statement #1 and #2 will compile successfully.
teste60.exercicio35.opcao_1         = B - Statement #2 and #3 will compile successfully.
teste60.exercicio35.opcao_2         = C - Statement #3 and #4 will compile successfully.
teste60.exercicio35.opcao_3         = D - Statement #4 and #1 will compile successfully.
teste60.exercicio35.opcao_4         = E - None of the Above
teste60.exercicio35.questao         = Consider the following program and choose the appropriate option:\r\n\r\nimport java.util.*;\r\n\r\nclass Test {\r\n\u0009public static void main(String []args) {\r\n\u0009\u0009Map<String, int> map =\r\n\u0009\u0009new HashMap<int, String>(); //#1\r\n\u0009\u0009Map<String, String> map2 =\r\n\u0009\u0009new HashMap<String, String>(); //#2\r\n\u0009\u0009Map<String, String> map3 = new HashMap<>(); //#3\r\n\u0009\u0009Map<> map4 = new HashMap<String, String>(); //#4\r\n\u0009}\r\n\r\n}
teste60.exercicio35.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.41, p.530.
teste60.exercicio36.ajuda.cabecalho = Map
teste60.exercicio36.ajuda.conteudo  = TreeMap is a Map;\u2014a value is stored against a key, and the elements are sorted based on the key. Option c) is not possible since two values cannot exist for a key. In a Map, keys are sequential, so options a) and b) are not possible. Option e) is also not correct since you have overwritten the value 25 against key 5, which is not captured by option e).
teste60.exercicio36.enunExtra       = \ 
teste60.exercicio36.numOpcao        = Select 1 option
teste60.exercicio36.opcao_0         = A - {5=5, 10=10, 3=3, 5=25}
teste60.exercicio36.opcao_1         = B - {10=10, 3=3, 5=25}
teste60.exercicio36.opcao_2         = C - {3=3, 5=5, 5=25, 10=10}
teste60.exercicio36.opcao_3         = D - {3=3, 5=25, 10=10}
teste60.exercicio36.opcao_4         = E - {3=3, 5=5, 10=10}
teste60.exercicio36.questao         = Consider the following program and predict the output:\r\n\r\nimport java.util.*;\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Map<Integer, String> map = new TreeMap<Integer, String>();\r\n\u0009\u0009map.put(5, "5");\r\n\u0009\u0009map.put(10, "10");\r\n\u0009\u0009map.put(3, "3");\r\n\u0009\u0009map.put(5, "25");\r\n\u0009\u0009System.out.println(map);\r\n\u0009}\r\n}
teste60.exercicio36.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.42, p.531.
teste60.exercicio37.ajuda.cabecalho = List
teste60.exercicio37.ajuda.conteudo  = The method peek() retrieves an element from the head of the Deque and returns, but does not remove the element. Hence, there will be no impact on the Deque.
teste60.exercicio37.enunExtra       = \ 
teste60.exercicio37.numOpcao        = Select 1 option
teste60.exercicio37.opcao_0         = A - [10, 20]
teste60.exercicio37.opcao_1         = B - [20, 10]
teste60.exercicio37.opcao_2         = C - []
teste60.exercicio37.opcao_3         = D - NoSuchElementException thrown when executing the line #1.
teste60.exercicio37.opcao_4         = E - None of the Above.
teste60.exercicio37.questao         = Consider the following program and predict the output:\r\n\r\nimport java.util.*;\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Deque<Integer> deque = new LinkedList<>();\r\n\u0009\u0009deque.add(10);\r\n\u0009\u0009deque.add(20);\r\n\u0009\u0009deque.peek();\r\n\u0009\u0009deque.peek();\r\n\u0009\u0009deque.peek(); // #1\r\n\u0009\u0009System.out.println(deque);\r\n\u0009}\r\n}
teste60.exercicio37.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.43, p.531.
teste60.exercicio38.ajuda.cabecalho = List
teste60.exercicio38.ajuda.conteudo  = The classes IdentityHashMap and Hashtable derive from the Map interface, so the assignments in the b) and c) options will compile without errors. NavigableMap and ConcurrentMap are interfaces that derive from the Map interface, and interfaces cannot be instantiated; hence the assignments in options a) and d) will result in compiler errors.
teste60.exercicio38.enunExtra       = \ 
teste60.exercicio38.numOpcao        = Select 2 options
teste60.exercicio38.opcao_0         = A - Map<String, String> map1 = new NavigableMap<>();
teste60.exercicio38.opcao_1         = B - Map<String, String> map2 = new IdentityHashMap<>();
teste60.exercicio38.opcao_2         = C - Map<String, String> map3 = new Hashtable<>();
teste60.exercicio38.opcao_3         = D - Map<String, String> map4 = new ConcurrentMap<>();
teste60.exercicio38.opcao_4         = E - None of the Above.
teste60.exercicio38.questao         = Which TWO of the following options provide assignments that will compile without errors?
teste60.exercicio38.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.50, p.534.
teste60.exercicio39.ajuda.cabecalho = List
teste60.exercicio39.ajuda.conteudo  = The Arrays.asList method returns a List object that is backed by a fixed-length array. You cannot modify the List object returned by this array, so calling methods such as add() or remove() will result in throwing an UnsupportedOperationException.
teste60.exercicio39.enunExtra       = \ 
teste60.exercicio39.numOpcao        = Select 1 option
teste60.exercicio39.opcao_0         = A - When compiled, this program will result in a compiler error in linked marked with comment REMOVE.
teste60.exercicio39.opcao_1         = B - When run, this program will crash with throwing the exception UnsupportedOperationException \r\nwhen executing the line marked with comment REMOVE.
teste60.exercicio39.opcao_2         = C - When run, this program will print the following output: [hello, world, helloworld]
teste60.exercicio39.opcao_3         = D - When run, this program will print the following output: [world, helloworld!]
teste60.exercicio39.opcao_4         = E - When run, this program will print the following output: [world, helloworld]
teste60.exercicio39.questao         = Consider the following program:\r\n\r\nimport java.util.*;\r\n\r\nclass AsList {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009String hello = "hello";\r\n\u0009\u0009String world = "world";\r\n\u0009\u0009StringBuffer helloWorld = new StringBuffer(hello + world);\r\n\u0009\u0009List<String> list = Arrays.asList(hello, world, helloWorld.toString());\r\n\u0009\u0009helloWorld.append("!");\r\n\u0009\u0009list.remove(0); // REMOVE\r\n\u0009\u0009System.out.println(list);\r\n\u0009}\r\n}
teste60.exercicio39.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.51, p.534.
teste60.exercicio4.ajuda.cabecalho  = String
teste60.exercicio4.ajuda.conteudo   = The string concatenation operator works as follows: if both the operands are numbers, it performs the addition; otherwise it concats the arguments by calling the toString() method if needed. It evaluates from left to right. Hence, the expression in the program results in the string 115110.
teste60.exercicio4.enunExtra        = \ 
teste60.exercicio4.numOpcao         = Select 1 option
teste60.exercicio4.opcao_0          = A - 11511
teste60.exercicio4.opcao_1          = B - 1105110
teste60.exercicio4.opcao_2          = C - 115110
teste60.exercicio4.opcao_3          = D - 27
teste60.exercicio4.opcao_4          = E - 28
teste60.exercicio4.questao          = Consider the following program and predict the output:\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009String s = new String("5");\r\n\u0009\u0009System.out.println(1 + 10 + s + 1 + 10);\r\n\u0009}\r\n}
teste60.exercicio4.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.52, p.535.
teste60.exercicio40.ajuda.cabecalho = String
teste60.exercicio40.ajuda.conteudo  = The rule specified in the earlier explanation applies here also. However, here, the order of computation is changed using brackets. Hence, the + operator adds the numbers in the brackets first, and you get 11.5511.5.
teste60.exercicio40.enunExtra       = \ 
teste60.exercicio40.numOpcao        = Select 1 option
teste60.exercicio40.opcao_0         = A - 11.5511.5
teste60.exercicio40.opcao_1         = 11.551.010.5
teste60.exercicio40.opcao_2         = C - 1.010.551.010.5
teste60.exercicio40.opcao_3         = D - 11.55(1.010.5)
teste60.exercicio40.opcao_4         = E - 11.55(11.5)
teste60.exercicio40.questao         = Consider the following program and predict the output:\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009String s = new String("5");\r\n\u0009\u0009System.out.println(1.0 + 10.5 + s + (1.0 + 10.5));\r\n\u0009}\r\n}
teste60.exercicio40.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.53, p.535.
teste60.exercicio41.ajuda.cabecalho = String
teste60.exercicio41.ajuda.conteudo  = The first contact does not match with the specified regex (since \u201C.\u201D is not covered by \u201C\\w+\u201D); hence, the first part of the string is unchanged. The second part of string matches with the specified regex, so the replace rearranges the substring.
teste60.exercicio41.enunExtra       = \ 
teste60.exercicio41.numOpcao        = Select 1 option
teste60.exercicio41.opcao_0         = A - 9876543210: N.,Suneetha, 9898989898: Patil,Pratish
teste60.exercicio41.opcao_1         = B - Suneetha N.=9876543210, Pratish Patil=9898989898
teste60.exercicio41.opcao_2         = C - Suneetha N.=9876543210, 9898989898: Patil,Pratish
teste60.exercicio41.opcao_3         = D - This program throws a runtime exception.
teste60.exercicio41.opcao_4         = E - None of the Above
teste60.exercicio41.questao         = Consider the following program and predict the output:\r\n\r\nimport java.util.regex.*;\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009String str = "Suneetha N.=9876543210, Pratish Patil=9898989898";\r\n\u0009\u0009Pattern pattern = Pattern.compile("(\\\\w+)(\\\\s\\\\w+)(=)(\\\\d{10})");\r\n\u0009\u0009Matcher matcher = pattern.matcher(str);\r\n\u0009\u0009String newStr = matcher.replaceAll("$4:$2,$1");\r\n\u0009\u0009System.out.println(newStr);\r\n\u0009}\r\n}
teste60.exercicio41.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.60, p.538.
teste60.exercicio42.ajuda.cabecalho = System.in, System.out, and System.err
teste60.exercicio42.ajuda.conteudo  = System.in is of type InputStream, and both System.out and System.err are of type PrintStream. These are byte streams, though they are usually used for reading and writing characters from or to the console.
teste60.exercicio42.enunExtra       = \ 
teste60.exercicio42.numOpcao        = Select 2 options
teste60.exercicio42.opcao_0         = A - System.in is of type InputStream.
teste60.exercicio42.opcao_1         = B - System.in is of type FileReader.
teste60.exercicio42.opcao_2         = C - System.out is of type OutputStream.
teste60.exercicio42.opcao_3         = D - System.err is of type ErrorStream.
teste60.exercicio42.opcao_4         = E - Both System.out and System.err are of type PrintStream.
teste60.exercicio42.questao         = Which of the following TWO statements are true about the pre-defined streams System.in, System.out, and System.err?
teste60.exercicio42.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.61, p.539.
teste60.exercicio43.ajuda.cabecalho = Exception and Try..Catch
teste60.exercicio43.ajuda.conteudo  = The types implementing AutoCloseable can be used with a try-with-resources statement. The Closeable interface extends AutoCloseable, so classes implementing Closeable can also be used with a try-with-resources statement.
teste60.exercicio43.enunExtra       = \r\n\r\nWhich one of the following options correctly shows the output of this program when the program is executed?
teste60.exercicio43.numOpcao        = Select 1 option
teste60.exercicio43.opcao_0         = A - This program does not print any output in console.
teste60.exercicio43.opcao_1         = B - This program prints the following output: In AutoCloseableImpl.close()
teste60.exercicio43.opcao_2         = C - This program prints the following output: In AutoCloseableImpl.close()  /  In CloseableImpl.close()
teste60.exercicio43.opcao_3         = D - This program prints the following output: In CloseableImpl.close()  /  In AutoCloseableImpl.close()
teste60.exercicio43.opcao_4         = E - None of the Above.
teste60.exercicio43.questao         = Consider the following program:\r\n\r\nimport java.io.*;\r\n\r\nclass CloseableImpl implements Closeable {\r\n\u0009public void close() throws IOException {\r\n\u0009\u0009System.out.println("In CloseableImpl.close()");\r\n\u0009}\r\n}\r\n\r\nclass AutoCloseableImpl implements AutoCloseable {\r\n\u0009public void close() throws Exception {\r\n\u0009\u0009System.out.println("In AutoCloseableImpl.close()");\r\n\u0009}\r\n}\r\n\r\nclass AutoCloseCheck {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009try (Closeable closeableImpl = new CloseableImpl();\r\n\u0009\u0009\u0009\u0009AutoCloseable autoCloseableImpl = new AutoCloseableImpl()) {\r\n\u0009\u0009} catch (Exception ignore) {\r\n\u0009\u0009\u0009// do nothing\r\n\u0009\u0009} finally {\r\n\u0009\u0009\u0009// do nothing\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio43.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.62, p.539.
teste60.exercicio44.ajuda.cabecalho = Exception
teste60.exercicio44.ajuda.conteudo  = Both of the specified exceptions belong to same hierarchy (FileNotFoundException derives from an IOException), so you cannot specify both exceptions together in the multi-catch handler block.
teste60.exercicio44.enunExtra       = \ 
teste60.exercicio44.numOpcao        = Select 1 option
teste60.exercicio44.opcao_0         = A - The code snippet will compile without any errors.
teste60.exercicio44.opcao_1         = B - The compiler will report an error at statement #1.
teste60.exercicio44.opcao_2         = C - The compiler will report an error at statement #2.
teste60.exercicio44.opcao_3         = D - The compiler will report errors at statements #1 and #2.
teste60.exercicio44.opcao_4         = E - None of the Above.
teste60.exercicio44.questao         = Consider the following code snippet and choose the best option:\r\n\r\npublic static void main(String[] files) {\r\n\u0009try (FileReader inputFile = new FileReader(new File(files[0]))) { // #1\r\n\u0009} catch (FileNotFoundException | IOException e) { // #2\r\n\u0009\u0009e.printStackTrace();\r\n\u0009}\r\n}
teste60.exercicio44.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.63, p.540.
teste60.exercicio45.ajuda.cabecalho = Exception
teste60.exercicio45.ajuda.conteudo  = The statement Runtime.runFinalizersOnExit(true); makes sure that the finalize method is invoked when the application exits (although the method runFinalizersOnExit() is now deprecated). Here, the dynamic type of the object is \u201CDerived,\u201D so the finalize() method of the Derived class is invoked before the application exits.
teste60.exercicio45.enunExtra       = \ 
teste60.exercicio45.numOpcao        = Select 1 option
teste60.exercicio45.opcao_0         = A - This program prints the following: in Base.finalize.
teste60.exercicio45.opcao_1         = B - This program prints the following: in Derived.finalize.
teste60.exercicio45.opcao_2         = C - This program throws a CannotRunFinalizersOnExitException.
teste60.exercicio45.opcao_3         = D - This program throws a NullPointerException.
teste60.exercicio45.opcao_4         = E - None of the Above.
teste60.exercicio45.questao         = Consider the following program and predict the output:\r\n\r\nclass Base {\r\n\u0009protected void finalize() {\r\n\u0009\u0009System.out.println("in Base.finalize");\r\n\u0009}\r\n}\r\n\r\nclass Derived extends Base {\r\n\u0009protected void finalize() {\r\n\u0009\u0009System.out.println("in Derived.finalize");\r\n\u0009}\r\n}\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Derived d = new Derived();\r\n\u0009\u0009d = null;\r\n\u0009\u0009Runtime.runFinalizersOnExit(true);\r\n\u0009}\r\n}
teste60.exercicio45.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.70, p.544.
teste60.exercicio46.ajuda.cabecalho = Try .. Catch and finally
teste60.exercicio46.ajuda.conteudo  = The variable mem is 0 initially. It is incremented by one in the try block and is incremented further in the finally block to 2. Note that finally will always execute irrespective of whether an exception is thrown in the try block or not. Hence, the program will print 2.
teste60.exercicio46.enunExtra       = \ 
teste60.exercicio46.numOpcao        = Select 1 option
teste60.exercicio46.opcao_0         = A - 0
teste60.exercicio46.opcao_1         = B - 1
teste60.exercicio46.opcao_2         = C - 2
teste60.exercicio46.opcao_3         = D - 3
teste60.exercicio46.opcao_4         = E - 4
teste60.exercicio46.questao         = Consider the following program and predict the output:\r\n\r\nclass Test {\r\n\u0009private static int mem = 0;\r\n\r\n\u0009public static void foo() {\r\n\u0009\u0009try {\r\n\u0009\u0009\u0009mem = mem + 1;\r\n\u0009\u0009} catch (Exception e) {\r\n\u0009\u0009\u0009e.printStackTrace();\r\n\u0009\u0009} finally {\r\n\u0009\u0009\u0009mem = mem + 1;\r\n\u0009\u0009}\r\n\u0009}\r\n\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009foo();\r\n\u0009\u0009System.out.println(mem);\r\n\u0009}\r\n}
teste60.exercicio46.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.71, p.544.
teste60.exercicio47.ajuda.cabecalho = Try .. Catch
teste60.exercicio47.ajuda.conteudo  = The statement assert true; when executed will always succeed. The statement assert true; when executed will always fail. Remember that assertions are disabled by default, and \u2013ea enables the assertion for the whole program. However, -da disables assertions, and \u2013da:Derived instructs the JVM to disable assertions in the Derived class. Hence, the program completes execution normally without producing any output or throwing any exceptions.
teste60.exercicio47.enunExtra       = \r\n\r\nFrom the command line, this program is invoked as follows:\r\n\r\njava -ea -da:Derived AssertionCheck\r\n\r\nWhich one of the following options correctly describes the behavior of this program when it is run?
teste60.exercicio47.numOpcao        = Select 1 option
teste60.exercicio47.opcao_0         = A - This program crashes throwing an AssertionError in line marked with comment ASSERT_BASE.
teste60.exercicio47.opcao_1         = B - This program crashes throwing an AssertionError in line marked with comment ASSERT_DERIVED.
teste60.exercicio47.opcao_2         = C - This program first prints \u201CCaught exception\u201D and then crashes throwing an AssertionError in line \r\nmarked with comment ASSERT_DERIVED.
teste60.exercicio47.opcao_3         = D - This program completes execution normally without producing any output or throwing any exceptions.
teste60.exercicio47.opcao_4         = E - None of the Above.
teste60.exercicio47.questao         = Consider the following program:\r\n\r\nclass Base {\r\n\u0009public void foo() {\r\n\u0009\u0009assert true; // ASSERT_BASE\r\n\u0009}\r\n}\r\n\r\nclass Derived extends Base {\r\n\u0009public void foo() {\r\n\u0009\u0009assert false; // ASSERT_DERIVED\r\n\u0009}\r\n}\r\n\r\nclass AssertionCheck {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009try {\r\n\u0009\u0009\u0009Base base = new Base();\r\n\u0009\u0009\u0009base.foo();\r\n\u0009\u0009} catch (Exception e) {\r\n\u0009\u0009\u0009base = new Derived();\r\n\u0009\u0009\u0009base.foo();\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio47.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.72, p.545.
teste60.exercicio48.ajuda.cabecalho = Exception
teste60.exercicio48.ajuda.conteudo  = Tip: IOException is the base class for FileNotFoundException.
teste60.exercicio48.enunExtra       = \r\n\r\nAssume that srcFile and dstFile are Strings. Which one of the following options correctly describes the behavior of this program?
teste60.exercicio48.numOpcao        = Select 1 option
teste60.exercicio48.opcao_0         = A - This program will get into an infinite loop because the condition check for end-of-stream (checking != -1) is incorrect.
teste60.exercicio48.opcao_1         = B - This program will get into an infinite loop because the variable ch is declared as int instead of char.
teste60.exercicio48.opcao_2         = C - This program will result in a compiler error in line marked with comment TRY-BLOCK because you need to use , \r\n(comma) instead of ; (semi-colon) as separator for opening multiple resources.
teste60.exercicio48.opcao_3         = D - This program will result in a compiler error in line marked with comment MULTI-CATCH-BLOCK because \r\nIOException is the base class for FileNotFoundException.
teste60.exercicio48.opcao_4         = E - None of the Above.
teste60.exercicio48.questao         = Consider the following code segment:\r\n\r\ntry (BufferedReader inputFile = new BufferedReader(new FileReader(srcFile));\r\n\u0009\u0009BufferedWriter outputFile = new BufferedWriter(new FileWriter(dstFile))) { // TRY-BLOCK\r\n\u0009int ch = 0;\r\n\u0009while ((ch = inputFile.read()) != -1) {\r\n\u0009\u0009outputFile.write((char) ch);\r\n\u0009}\r\n} catch (FileNotFoundException | IOException exception) { // MULTI-CATCH-BLOCK\r\n\u0009System.err.println("Error in opening or processing file " + exception.getMessage());\r\n}
teste60.exercicio48.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.73, p.546.
teste60.exercicio49.ajuda.cabecalho = Locale and Files.
teste60.exercicio49.ajuda.conteudo  = The static public final Locale US member in the Locale class is accessed using the expression Locale.US.
teste60.exercicio49.enunExtra       = \ 
teste60.exercicio49.numOpcao        = Select 1 option
teste60.exercicio49.opcao_0         = A - Locale locale1 = new Locale.US;
teste60.exercicio49.opcao_1         = B - Locale locale2 = Locale.US;
teste60.exercicio49.opcao_2         = C - Locale locale3 = new US.Locale();
teste60.exercicio49.opcao_3         = D - Locale locale4 = Locale("US");
teste60.exercicio49.opcao_4         = E - Locale locale5 = new Locale(Locale.US);
teste60.exercicio49.questao         = Which one of the following statements will compile without errors?
teste60.exercicio49.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.80, p.549.
teste60.exercicio5.ajuda.cabecalho  = Calendar and Exception
teste60.exercicio5.ajuda.conteudo   = The format specifier %t allows for formatting date and time information. It takes as suffix the format and part of the date or time information. The format Y is for the year displayed in four digits. The format m is for month as decimal (with months in the range 01 to 12). The format d is for the day of month as decimal (with the days in the range 01 \u2013 31).
teste60.exercicio5.enunExtra        = \ \r\n\r\nWhich one of the following options is correct?
teste60.exercicio5.numOpcao         = Select 1 option
teste60.exercicio5.opcao_0          = A - The program throws a MissingFormatArgumentException.
teste60.exercicio5.opcao_1          = B - The program throws an UnknownFormatConversionException.
teste60.exercicio5.opcao_2          = C - The program prints the following: 2012/02/01.
teste60.exercicio5.opcao_3          = D - The program prints the following: 12/Feb/01.
teste60.exercicio5.opcao_4          = E - None of the Above.
teste60.exercicio5.questao          = Consider the following program:\r\n\r\nimport java.util.*;\r\n\r\nclass Format {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Formatter formatter = new Formatter();\r\n\u0009\u0009Calendar calendar = Calendar.getInstance(Locale.US);\r\n\u0009\u0009calendar.set(/* year = */ 2012, /* month = */ Calendar.FEBRUARY,\r\n\u0009\u0009\u0009\u0009/* date = */ 1);\r\n\u0009\u0009formatter.format("%tY/%tm/%td", calendar, calendar, calendar);\r\n\u0009\u0009System.out.println(formatter);\r\n\u0009}\r\n}
teste60.exercicio5.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.81, p.549.
teste60.exercicio50.ajuda.cabecalho = Files
teste60.exercicio50.ajuda.conteudo  = Tip: Closeable extends AutoCloseable and define close().
teste60.exercicio50.enunExtra       = \ 
teste60.exercicio50.numOpcao        = Select 1 option
teste60.exercicio50.opcao_0         = A - Interface Closeable extends AutoCloseable and defines one method, close().
teste60.exercicio50.opcao_1         = B - Interface Autocloseable extends Closeable and defines one method, close().
teste60.exercicio50.opcao_2         = C - Interface Closeable extends AutoCloseable and does not define any method.
teste60.exercicio50.opcao_3         = D - Interface AutoCloseable extends Closeable and does not define any method.
teste60.exercicio50.opcao_4         = E - Closeable and AutoCloseable interfaces do not share any inheritance relationship.
teste60.exercicio50.questao         = Which one of the following statements is correct with respect to Closeable and AutoCloseable interfaces?
teste60.exercicio50.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.82, p.550.
teste60.exercicio51.ajuda.cabecalho = Thread
teste60.exercicio51.ajuda.conteudo  = You have overridden the start() method, so the run() method is never called!
teste60.exercicio51.enunExtra       = \ 
teste60.exercicio51.numOpcao        = Select 1 option
teste60.exercicio51.opcao_0         = A - in start oops  /  in ctor oops
teste60.exercicio51.opcao_1         = B - in start oops  /  in run oops  /  in ctor oops
teste60.exercicio51.opcao_2         = C - in start oops  /  in ctor oops  /  in run oops
teste60.exercicio51.opcao_3         = D - in ctor oops  /  in start oops  /  in run oops
teste60.exercicio51.opcao_4         = E - None of the Above.
teste60.exercicio51.questao         = Consider the following program and predict the output:\r\n\r\nclass MyThread extends Thread {\r\n\u0009public MyThread(String name) {\r\n\u0009\u0009this.setName(name);\r\n\u0009\u0009start();\r\n\u0009\u0009System.out.println("in ctor " + getName());\r\n\u0009}\r\n\r\n\u0009public void start() {\r\n\u0009\u0009System.out.println("in start " + getName());\r\n\u0009}\r\n\r\n\u0009public void run() {\r\n\u0009\u0009System.out.println("in run " + getName());\r\n\u0009}\r\n}\r\n\r\nclass Test {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009new MyThread("oops");\r\n\u0009}\r\n}
teste60.exercicio51.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.84, p.551.
teste60.exercicio52.ajuda.cabecalho = Thread
teste60.exercicio52.ajuda.conteudo  = The executor interface has overloaded the submit() method that takes \u201Ca value-returning the task for execution and returns a Future representing the pending results of the task.\u201D
teste60.exercicio52.enunExtra       = \ 
teste60.exercicio52.numOpcao        = Select 1 option
teste60.exercicio52.opcao_0         = A - The overloaded submit() method declared in the ExecutorService interface.
teste60.exercicio52.opcao_1         = B - The execute() method declared in the Executor interface.
teste60.exercicio52.opcao_2         = C - The call() method declared in the Callable interface.
teste60.exercicio52.opcao_3         = D - The run() method declared in the Runnable interface.
teste60.exercicio52.opcao_4         = E - None of the Above.
teste60.exercicio52.questao         = Which one of the following methods returns a Future object?
teste60.exercicio52.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.85, p.551.
teste60.exercicio53.ajuda.cabecalho = Lock
teste60.exercicio53.ajuda.conteudo  = In a re-entrant lock, you can acquire the same lock again. However, you need to release that lock the same number of times.
teste60.exercicio53.enunExtra       = \r\n\r\nWhich one of the following options is correct?
teste60.exercicio53.numOpcao        = Select 1 option
teste60.exercicio53.opcao_0         = A - This program will throw an IllegalMonitorStateException in the line marked with comment LOCK_2.
teste60.exercicio53.opcao_1         = B - This program will throw an IllegalMonitorStateException in the line marked with comment UNLOCK_1.
teste60.exercicio53.opcao_2         = C - This program will throw an UnsupportedOperationException in the line marked with comment UNLOCK_1.
teste60.exercicio53.opcao_3         = D - This program prints the following: Lock 1 Critical section 1 Lock 2 Critical section 2 Unlock 2 Unlock 1.
teste60.exercicio53.opcao_4         = E - None of the Above.
teste60.exercicio53.questao         = Consider the following program:\r\n\r\nimport java.util.concurrent.locks.*;\r\n\r\nclass LockUnlock {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Lock lock = new ReentrantLock();\r\n\u0009\u0009try {\r\n\u0009\u0009\u0009System.out.print("Lock 1 ");\r\n\u0009\u0009\u0009lock.lock();\r\n\u0009\u0009\u0009System.out.print("Critical section 1 ");\r\n\u0009\u0009\u0009System.out.print("Lock 2 ");\r\n\u0009\u0009\u0009lock.lock(); // LOCK_2\r\n\u0009\u0009\u0009System.out.print("Critical section 2 ");\r\n\u0009\u0009} finally {\r\n\u0009\u0009\u0009lock.unlock();\r\n\u0009\u0009\u0009System.out.print("Unlock 2 ");\r\n\u0009\u0009\u0009lock.unlock(); // UNLOCK_1\r\n\u0009\u0009\u0009System.out.print("Unlock 1 ");\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio53.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.86, p.552.
teste60.exercicio54.ajuda.cabecalho = Thread and Lock
teste60.exercicio54.ajuda.conteudo  = Note that in this program you call the lock() method on the lock1 variable and call the unlock() method on the lock2 variable. Hence, in lock2.unlock(), you are attempting to call unlock() before calling lock() on a Lock object and this results in throwing an IllegalMonitorStateException.
teste60.exercicio54.enunExtra       = \ 
teste60.exercicio54.numOpcao        = Select 1 option
teste60.exercicio54.opcao_0         = A - This program will print the following: \u201CGoing to lock\u2026\u201D  /  \u201CIn critical section\u201D  /  Unlocking \u2026
teste60.exercicio54.opcao_1         = B - This program will print the following: \u201CGoing to lock\u2026\u201D  /  \u201CIn critical section\u201D  /  and then terminate normally.
teste60.exercicio54.opcao_2         = C - This program will print the following: \u201CGoing to lock\u2026\u201D  /  \u201CIn critical section\u201D  /  and then enter into a deadlock \r\nbecause lock2.unlock() waits for lock2 to get locked first.
teste60.exercicio54.opcao_3         = D - This program will throw an IllegalMonitorStateException.
teste60.exercicio54.opcao_4         = E - None of the Above.
teste60.exercicio54.questao         = Consider the following program:\r\n\r\nimport java.util.concurrent.locks.*;\r\n\r\nclass LockUnlock {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Lock lock1 = new ReentrantLock();\r\n\u0009\u0009Lock lock2 = new ReentrantLock();\r\n\u0009\u0009try {\r\n\u0009\u0009\u0009System.out.println("Going to lock...");\r\n\u0009\u0009\u0009lock1.lock();\r\n\u0009\u0009\u0009System.out.println("In critical section");\r\n\u0009\u0009} finally {\r\n\u0009\u0009\u0009lock2.unlock();\r\n\u0009\u0009\u0009System.out.println("Unlocking ...");\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio54.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.87, p.552.
teste60.exercicio55.ajuda.cabecalho = Thread
teste60.exercicio55.ajuda.conteudo  = The second parameter states the fairness policy of the semaphore object. However, there are two permits for the semaphore object; so you cannot predict the order in which waiting people will get the permission to access the ATM.
teste60.exercicio55.enunExtra       = \ \r\n\r\nWhich one of the options is true if you replace the statement #1 with the following statement?\r\n\r\nSemaphore machines = new Semaphore(2, true);
teste60.exercicio55.numOpcao        = Select 1 option
teste60.exercicio55.opcao_0         = A - The exact order in which waiting persons will get the ATM machine cannot be predicted.
teste60.exercicio55.opcao_1         = B - The ATM machine will be accessed in the order of waiting persons (because of the second parameter in semaphore constructor).
teste60.exercicio55.opcao_2         = C - It will not compile since second parameter in semaphore instantiation is not allowed.
teste60.exercicio55.opcao_3         = D - It will result in throwing an IllegalMonitorStateException.
teste60.exercicio55.opcao_4         = E - None of the Above.
teste60.exercicio55.questao         = Consider the following program:\r\n\r\nimport java.util.concurrent.Semaphore;\r\n\r\nclass ATMRoom {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Semaphore machines = new Semaphore(2); // #1\r\n\u0009\u0009new Person(machines, "Mickey");\r\n\u0009\u0009new Person(machines, "Donald");\r\n\u0009\u0009new Person(machines, "Tom");\r\n\u0009\u0009new Person(machines, "Jerry");\r\n\u0009\u0009new Person(machines, "Casper");\r\n\u0009}\r\n}\r\n\r\nclass Person extends Thread {\r\n\u0009private Semaphore machines;\r\n\r\n\u0009public Person(Semaphore machines, String name) {\r\n\u0009\u0009this.machines = machines;\r\n\u0009\u0009this.setName(name);\r\n\u0009\u0009this.start();\r\n\u0009}\r\n\r\n\u0009public void run() {\r\n\u0009\u0009try {\r\n\u0009\u0009\u0009System.out.println(getName() + " waiting to access an ATM machine");\r\n\u0009\u0009\u0009machines.acquire();\r\n\u0009\u0009\u0009System.out.println(getName() + " is accessing an ATM machine");\r\n\u0009\u0009\u0009Thread.sleep(1000);\r\n\u0009\u0009\u0009System.out.println(getName() + " is done using the ATM machine");\r\n\u0009\u0009\u0009machines.release();\r\n\u0009\u0009} catch (InterruptedException ie) {\r\n\u0009\u0009\u0009System.err.println(ie);\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio55.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.88, p.552.
teste60.exercicio56.ajuda.cabecalho = Synchronization
teste60.exercicio56.ajuda.conteudo  = Tip: CyclicBarrier is used when threads may need to wait at a predefined execution point until all other threads reach that point. This construct matches the given requirements.
teste60.exercicio56.enunExtra       = \ 
teste60.exercicio56.numOpcao        = Select 1 option
teste60.exercicio56.opcao_0         = A - Exchanger
teste60.exercicio56.opcao_1         = B - Lock
teste60.exercicio56.opcao_2         = C - CyclicBarrier
teste60.exercicio56.opcao_3         = D - RecursiveAction
teste60.exercicio56.opcao_4         = E - None of the Above.
teste60.exercicio56.questao         = A couple of friends are waiting for some more friends to come so that they can go to a restaurant for dinner. Which synchronization construct could be used here to programmatically simulate this situation?
teste60.exercicio56.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.89, p.554.
teste60.exercicio57.ajuda.cabecalho = ResultSet
teste60.exercicio57.ajuda.conteudo  = Tip: You cannot use column names to retrieve both the values.
teste60.exercicio57.enunExtra       = \ 
teste60.exercicio57.numOpcao        = Select 1 option
teste60.exercicio57.opcao_0         = A - You can retrieve both the column values using column names.
teste60.exercicio57.opcao_1         = B - You can retrieve both the column values using column names; however, you need to specify the column names \r\nusing the column index (i.e. column-name:column-index).
teste60.exercicio57.opcao_2         = C - You cannot use column names to retrieve both the values; you need to use column index to do it.
teste60.exercicio57.opcao_3         = D - Both options b and c will work.
teste60.exercicio57.opcao_4         = E - None of the Above.
teste60.exercicio57.questao         = An application establishes connection with a database, which returns a resultset containing two identical column names. You are using ResultSet to retrieve the associated values. In this context, which statement is true?
teste60.exercicio57.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.90, p.554.
teste60.exercicio58.ajuda.cabecalho = Output 
teste60.exercicio58.ajuda.conteudo  = The readLine() method returns a String object while the readPassword() method returns an array of char.
teste60.exercicio58.enunExtra       = \ 
teste60.exercicio58.numOpcao        = Select 1 option
teste60.exercicio58.opcao_0         = A - String userName = null;  /  char[] password = null;
teste60.exercicio58.opcao_1         = B - String userName = null;  /  String password = null;
teste60.exercicio58.opcao_2         = C - char[] userName = null;  /  String password = null;
teste60.exercicio58.opcao_3         = D - char[] userName = null;  /  char[] password = null;
teste60.exercicio58.opcao_4         = E - None of the Above.
teste60.exercicio58.questao         = Consider the following program and replace the statement #1 and #2 with appropriate declarations:\r\n\r\nimport java.io.Console;\r\n\r\nclass Login {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009Console console = System.console();\r\n\u0009\u0009if (console != null) {\r\n\u0009\u0009\u0009// #1\r\n\u0009\u0009\u0009// #2\r\n\u0009\u0009\u0009userName = console.readLine("Enter your username: ");\r\n\u0009\u0009\u0009password = console.readPassword("Enter password: ");\r\n\u0009\u0009\u0009System.out.println(userName + " ," + password);\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio58.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.74, p.546.
teste60.exercicio59.ajuda.cabecalho = Output of Files
teste60.exercicio59.ajuda.conteudo  = The read() method returns the value \u22121 if end-of-stream (EOS) is reached, which is checked in this while loop.
teste60.exercicio59.enunExtra       = \r\n\r\nAssume that inputFile is of type FileReader, and outputFile is of type FileWriter, and ch is of type char. The method read() returns the character if successful, or VAL if the end of the stream has been reached. What is the correct value of this VAL checked in the while loop for end-of-stream?
teste60.exercicio59.numOpcao        = Select 1 option
teste60.exercicio59.opcao_0         = A - Integer.MIN_VALUE
teste60.exercicio59.opcao_1         = B - 0
teste60.exercicio59.opcao_2         = C - 255
teste60.exercicio59.opcao_3         = D - Integer.MAX_VALUE
teste60.exercicio59.opcao_4         = E - -1
teste60.exercicio59.questao         = Consider the following code segment:\r\n\r\nwhile( (ch = inputFile.read()) != VAL) {\r\n    outputFile.write( (char)ch );\r\n}
teste60.exercicio59.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.64, p.540.
teste60.exercicio6.ajuda.cabecalho  = System
teste60.exercicio6.ajuda.conteudo   = In first printf() method, %3.4s indicates that you want to print the first four characters of a string. In the second printf() method call, %05d indicates that you wanted to print a minimum five digits of an integer. If the number does not have enough digits, then the number will be preceded by leading zeroes.
teste60.exercicio6.enunExtra        = \ \r\n\r\nWhich one of the following options correctly provides the output of this program?
teste60.exercicio6.numOpcao         = Select 1 option
teste60.exercicio6.opcao_0          = A - lo  /  05123
teste60.exercicio6.opcao_1          = B - hell  /  0123
teste60.exercicio6.opcao_2          = C - hello  /  123
teste60.exercicio6.opcao_3          = D - hell  /  00123
teste60.exercicio6.opcao_4          = E - hello world /  123
teste60.exercicio6.questao          = Consider the following program:\r\n\r\nclass Printf {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009System.out.printf("%3.4s %n", "hello world");\r\n\u0009\u0009System.out.printf("%05d", 123);\r\n\u0009}\r\n}
teste60.exercicio6.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.54, p.535.
teste60.exercicio60.ajuda.cabecalho = Number
teste60.exercicio60.ajuda.conteudo  = Classes AtomicInteger and AtomicLong extend Number class.\r\nAtomicBoolean does not extend java.lang.Number. Classes named as AtomicFloat or AtomicDouble do not exist in the java.util.concurrent.atomic package.
teste60.exercicio60.enunExtra       = \ 
teste60.exercicio60.numOpcao        = Select 2 options
teste60.exercicio60.opcao_0         = A - AtomicBoolean
teste60.exercicio60.opcao_1         = B - AtomicInteger
teste60.exercicio60.opcao_2         = C - AtomicLong
teste60.exercicio60.opcao_3         = D - AtomicFloat
teste60.exercicio60.opcao_4         = E - AtomicDouble
teste60.exercicio60.questao         = Which of the following classes in the java.util.concurrent.atomic package inherit from java.lang.Number? (Select all that apply).
teste60.exercicio60.referencia      = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.44, p.531.
teste60.exercicio7.ajuda.cabecalho  = HashMap
teste60.exercicio7.ajuda.conteudo   = The lines marked with comments ADD_MAP and ADD_HASHMAP are valid uses of the diamond operator to infer type arguments. In the line marked with comment ITERATE, the Map type is not parameterized, so it will result in a warning (not a compiler error). Calling the add() method passing null does not result in a NullPointerException. The program, when run, will successfully print the output null, {}, {} (null output indicates a null value was added to the list, and the {} output indicates that Map is empty).
teste60.exercicio7.enunExtra        = \ \r\n\r\nWhich one of the following options is correct?
teste60.exercicio7.numOpcao         = Select 1 option
teste60.exercicio7.opcao_0          = A - This program will result in a compiler error in line marked with comment ADD_MAP.
teste60.exercicio7.opcao_1          = B - This program will result in a compiler error in line marked with comment ADD_HASHMAP.
teste60.exercicio7.opcao_2          = C - This program will result in a compiler error in line marked with comment ITERATE.
teste60.exercicio7.opcao_3          = D - When run, this program will crash, throwing a NullPointerException in line marked with comment ADD_NULL.
teste60.exercicio7.opcao_4          = E - When run, this program will print the following: null {} {}
teste60.exercicio7.questao          = Consider the following program:\r\n\r\nimport java.util.*;\r\n\r\nclass TemplateType {\r\n\u0009public static void main(String[] args) {\r\n\u0009\u0009List<Map<List<Integer>, List<String>>> list = new ArrayList<>(); // ADD_MAP\r\n\u0009\u0009Map<List<Integer>, List<String>> map = new HashMap<>();\r\n\u0009\u0009list.add(null); // ADD_NULL\r\n\u0009\u0009list.add(map);\r\n\u0009\u0009list.add(new HashMap<List<Integer>, List<String>>()); // ADD_HASHMAP\r\n\u0009\u0009for (Map element : list) { // ITERATE\r\n\u0009\u0009\u0009System.out.print(element + " ");\r\n\u0009\u0009}\r\n\u0009}\r\n}
teste60.exercicio7.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.34, p.527.
teste60.exercicio8.ajuda.cabecalho  = Inheritance
teste60.exercicio8.ajuda.conteudo   = When a class inherits from another class, they share an is-a relationship. On the other hand, if a class uses another class (by declaring an instance of another class), then the first class has a has-a relationship with the used class.
teste60.exercicio8.enunExtra        = \r\n\r\nWhich one of the following statements is true?
teste60.exercicio8.numOpcao         = Select 1 option
teste60.exercicio8.opcao_0          = A - Class Test is related with ClassA with a has-a relationship.
teste60.exercicio8.opcao_1          = B - Class Test is related to ClassC with a composition relationship.
teste60.exercicio8.opcao_2          = C - Class Test is related with String with an is-a relationship.
teste60.exercicio8.opcao_3          = D - Class ClassA is related with InterfaceB with an is-a relationship.
teste60.exercicio8.opcao_4          = E - None of the Above.
teste60.exercicio8.questao          = Consider the following program:\r\n\r\nclass ClassA {\r\n}\r\n\r\ninterface InterfaceB {\r\n}\r\n\r\nclass ClassC {\r\n}\r\n\r\nclass Test extends ClassA implements InterfaceB {\r\n\u0009String msg;\r\n\u0009ClassC classC;\r\n}
teste60.exercicio8.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.25, p.524.
teste60.exercicio9.ajuda.cabecalho  = Has-a relationship
teste60.exercicio9.ajuda.conteudo   = Composition is also known as a has-a relationship, and inheritance is known as an is-a relationship. The Composite pattern is a design pattern and is not an alternative name for a has-a relationship.
teste60.exercicio9.enunExtra        = \ 
teste60.exercicio9.numOpcao         = Select 1 option
teste60.exercicio9.opcao_0          = A - Inheritance
teste60.exercicio9.opcao_1          = B - Composite pattern
teste60.exercicio9.opcao_2          = C - Inner classes
teste60.exercicio9.opcao_3          = D - Composition
teste60.exercicio9.opcao_4          = E - None of the Above.
teste60.exercicio9.questao          = Which one of the following object-oriented concepts describes has-a relationship?
teste60.exercicio9.referencia       = GANESH, S G. SHARMA, Tushar. Oracle Certified Professional Java SE 7 Programmer Exams. 1.ed. EUA, q.24, p.524.
